(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{317:function(e,t,a){"use strict";a.r(t);var s=a(28),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"javascript-events-和dom-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-events-和dom-api"}},[e._v("#")]),e._v(" Javascript,Events 和DOM API")]),e._v(" "),a("p",[e._v("因为A-Frame只是HTML，所以我们可以使用JavaScript和domapi来控制场景及其实体，就像我们通常在web开发中那样。")]),e._v(" "),a("p",[e._v("场景中的每个元素，甚至是"),a("a-box",[e._v("或"),a("a-sky",[e._v("等元素，都是实体（表示为"),a("a-entity",[e._v("）。A-Frame修改HTML元素原型，为某些domapi添加一些额外的行为，使其适合A-Frame。有关下面讨论的大多数API的参考，请参阅实体API文档。")])],1)],1)],1),e._v(" "),a("h2",{attrs:{id:"在何处放置a-frame的javascript代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在何处放置a-frame的javascript代码"}},[e._v("#")]),e._v(" 在何处放置A-Frame的JavaScript代码")]),e._v(" "),a("p",[e._v("重要提示：在我们讨论使用JavaScript和domapi的不同方法之前，我们规定将JavaScript代码封装在A-Frame组件中。组件模块化代码，使逻辑和行为在HTML中可见，并确保代码在正确的时间执行（例如，在场景和实体附加和初始化之后）。作为最基本的示例，要在"),a("a-scene",[e._v("之前注册console.log组件：")])],1),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('log', {\n  schema: {type: 'string'},\n\n  init: function () {\n    var stringToLog = this.data;\n    console.log(stringToLog);\n  }\n});\n")])])]),a("p",[e._v("注册后，使用HTML中的组件：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<a-scene log="Hello, Scene!">\n  <a-box log="Hello, Box!"></a-box>\n</a-scene>\n')])])]),a("p",[e._v("组件将我们的所有代码封装为可重用、声明性和可共享的。不过，如果我们只是在运行时闲逛，我们可以使用浏览器的开发工具控制台在场景中运行JavaScript。")]),e._v(" "),a("p",[e._v("不要像使用传统的2D脚本那样，尝试在"),a("A-scene",[e._v("后面的raw"),a("code",[e._v("<script>")]),e._v("标记中放置与A-Frame相关的JavaScript。如果我们这样做了，我们就必须采取特殊措施来确保代码在正确的时间运行（请参见在场景中运行内容脚本）。")])],1),e._v(" "),a("h2",{attrs:{id:"通过查询和遍历获取实体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过查询和遍历获取实体"}},[e._v("#")]),e._v(" 通过查询和遍历获取实体")]),e._v(" "),a("p",[e._v("DOM作为场景图的奇妙之处在于，标准DOM提供了遍历、查询、查找和选择.querySelector（）和.querySelectorAll（）的实用程序。最初的灵感来自jQuery选择器，我们可以在MDN上学习查询选择器。")]),e._v(" "),a("p",[e._v("让我们运行几个示例查询选择器。以下面的场景为例。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<html>\n  <a-scene>\n    <a-box id="redBox" class="clickable" color="red"></a-box>\n    <a-sphere class="clickable" color="blue"></a-sphere>\n    <a-box color="green"></a-box>\n    <a-entity light="type: ambient"></a-entity>\n    <a-entity light="type: directional"></a-entity>\n  </a-scene>\n</html>\n')])])]),a("h3",{attrs:{id:"使用-queryselector（）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-queryselector（）"}},[e._v("#")]),e._v(" 使用.querySelector（）")]),e._v(" "),a("p",[e._v("如果我们只想获取一个元素，我们使用.querySelector（）返回一个元素。让我们抓住场景元素：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var sceneEl = document.querySelector('a-scene');\n")])])]),a("p",[e._v("注意如果我们在一个组件中工作，我们已经有了对scene元素的引用，而不需要查询。所有实体都引用其场景元素：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('foo', {\n  init: function () {\n    console.log(this.el.sceneEl);  // Reference to the scene element.\n  }\n});\n")])])]),a("p",[e._v("如果元素有ID，我们可以使用ID选择器（即#"),a("ID",[e._v("）。在对整个文档执行查询选择器之前，我们先获取一个带有ID的红色框。在这里，我们将在场景范围内执行查询选择器。使用查询选择器，我们可以将查询的范围限制在任何元素内：")])],1),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('var sceneEl = document.querySelector(\'a-scene\');\nconsole.log(sceneEl.querySelector(\'#redBox\'));\n// <a-box id="redBox" class="clickable" color="red"></a-box>\n')])])]),a("h3",{attrs:{id:"使用-queryselectorall（）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-queryselectorall（）"}},[e._v("#")]),e._v(" 使用.querySelectorAll（）")]),e._v(" "),a("p",[e._v("如果要获取一组元素，我们使用.querySelectorAll（）返回一个元素数组。我们可以跨元素名称查询：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('console.log(sceneEl.querySelectorAll(\'a-box\'));\n// [\n//  <a-box id="redBox" class="clickable" color="red"></a-box>,\n//  <a-box color="green"></a-box>\n// ]\n')])])]),a("p",[e._v("我们可以查询具有带有类选择器的类的元素（即<class_NAME>）。让我们抓住每个拥有可点击类的实体：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('console.log(sceneEl.querySelectorAll(\'.clickable\'));\n// [\n//  <a-box id="redBox" class="clickable" color="red"></a-box>\n//  <a-sphere class="clickable" color="blue"></a-sphere>\n// ]\n')])])]),a("p",[e._v("我们可以使用属性选择器（即，[<attribute\\u NAME>]）查询包含属性（在本例中是组件）的元素。让我们抓住每一个有光的实体：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('console.log(sceneEl.querySelectorAll(\'[light]\'));\n// [\n//  <a-entity light="type: ambient"></a-entity>\n// <a-entity light="type: directional"></a-entity>\n// ]\n')])])]),a("h3",{attrs:{id:"循环-queryselectorall-中的实体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#循环-queryselectorall-中的实体"}},[e._v("#")]),e._v(" 循环.querySelectorAll()中的实体")]),e._v(" "),a("p",[e._v("如果我们使用.querySelectorAll（）获取一组实体，我们可以使用for循环在它们上循环。让我们用*循环浏览场景中的每个元素。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var els = sceneEl.querySelectorAll('*');\nfor (var i = 0; i < els.length; i++) {\n  console.log(els[i]);\n}\n")])])]),a("h3",{attrs:{id:"关于性能的说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于性能的说明"}},[e._v("#")]),e._v(" 关于性能的说明")]),e._v(" "),a("p",[e._v("避免在每帧都被调用的tick和tock函数中使用.querySelector和.querySelector，因为在DOM上循环检索实体确实需要一些时间。相反，保留一个实体的缓存列表，预先调用查询选择器，然后在上面循环。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('query-selector-example', {\n  init: function () {\n    this.entities = document.querySelectorAll('.box');\n  },\n  \n  tick: function () {\n    // Don't call query selector in here, query beforehand.\n    for (let i = 0; i < this.entities.length; i++) {\n      // Do something with entities.\n    }\n  }\n});\n")])])]),a("h3",{attrs:{id:"使用-getattribute-检索组件数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-getattribute-检索组件数据"}},[e._v("#")]),e._v(" 使用.getAttribute()检索组件数据")]),e._v(" "),a("p",[e._v("我们可以通过.getAttribute获取实体组件的数据。A-Frame将.getAttribute扩展为返回值而不是字符串（例如，在大多数情况下返回对象，因为组件通常由多个属性组成，或者返回like.getAttribute（'visible'）的实际布尔值。通常，.getAttribute将返回组件的内部数据对象，因此不要直接修改该对象：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// <a-entity geometry="primitive: sphere; radius: 2"></a-entity>\nel.getAttribute(\'geometry\');\n// >> {"primitive": "sphere", "radius: 2", ...}\n')])])]),a("h3",{attrs:{id:"检索位置和刻度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#检索位置和刻度"}},[e._v("#")]),e._v(" 检索位置和刻度")]),e._v(" "),a("p",[e._v("执行el.getAttribute（'position'）或el.getAttribute（'scale'）将返回矢量3的3.js Object3D position和scale属性。请记住，修改这些对象将修改实际的实体数据。")]),e._v(" "),a("p",[e._v("这是因为A-Frame允许我们修改position、rotation、scale，在three.js级别可见，为了让.getAttribute返回正确的数据，A-Frame返回实际的three.js Object3D对象。")]),e._v(" "),a("p",[e._v("对于.getAttribute（'rotation'）这不是真的，因为A帧无论好坏，都使用度而不是弧度。在这种情况下，将返回具有x/y/z属性的普通JavaScript对象。如果需要在弧度较低的级别上工作，则可以通过el.Object3D.rotation检索Object3D Euler。")]),e._v(" "),a("h2",{attrs:{id:"修改a-frame场景图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#修改a-frame场景图"}},[e._v("#")]),e._v(" 修改A-Frame场景图")]),e._v(" "),a("p",[e._v("使用JavaScript和domapi，我们可以像使用普通HTML元素那样动态地添加和删除实体。")]),e._v(" "),a("h3",{attrs:{id:"使用-createelement（）创建实体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-createelement（）创建实体"}},[e._v("#")]),e._v(" 使用.createElement（）创建实体")]),e._v(" "),a("p",[e._v("要创建实体，可以使用document.createElement。这将给我们一个空白实体：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var el = document.createElement('a-entity');\n\n")])])]),a("p",[e._v("但是，在将该实体附加到场景之前，它不会初始化或成为场景的一部分。")]),e._v(" "),a("h3",{attrs:{id:"添加带有-appendchild（）的实体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#添加带有-appendchild（）的实体"}},[e._v("#")]),e._v(" 添加带有.appendChild（）的实体")]),e._v(" "),a("p",[e._v("要向DOM添加实体，可以使用.appendChild（element）。具体来说，我们想把它添加到我们的场景中。我们抓取场景，创建实体，并将实体附加到场景中。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var sceneEl = document.querySelector('a-scene');\nvar entityEl = document.createElement('a-entity');\n// Do `.setAttribute()`s to initialize the entity.\nsceneEl.appendChild(entityEl);\n\n")])])]),a("p",[e._v("注意.appendChild（）是浏览器中的异步操作。在实体完成对DOM的追加之前，我们不能对实体执行很多操作（例如调用.getAttribute（））。如果我们需要查询刚刚附加的实体上的属性，我们可以监听实体上加载的事件，或者将逻辑放在A-Frame组件中，以便在它准备好后执行它：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var sceneEl = document.querySelector('a-scene');\n\nAFRAME.registerComponent('do-something-once-loaded', {\n  init: function () {\n    // This will be called after the entity has properly attached and loaded.\n    console.log('I am ready!');\n  }\n});\n\nvar entityEl = document.createElement('a-entity');\nentityEl.setAttribute('do-something-once-loaded', '');\nsceneEl.appendChild(entityEl);\n\n")])])]),a("h3",{attrs:{id:"删除具有-removechild-的实体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除具有-removechild-的实体"}},[e._v("#")]),e._v(" 删除具有.removeChild()的实体")]),e._v(" "),a("p",[e._v("为了从DOM中移除实体，从而从场景中移除实体，我们从父元素中调用.removeChild（element）。如果我们有一个实体，我们必须要求其父（parentNode）移除该实体。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("entityEl.parentNode.removeChild(entityEl);\n")])])]),a("h2",{attrs:{id:"修改实体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#修改实体"}},[e._v("#")]),e._v(" 修改实体")]),e._v(" "),a("p",[e._v("空白实体什么都不做。我们可以通过添加组件、配置组件属性和删除组件来修改实体。")]),e._v(" "),a("h3",{attrs:{id:"使用-setattribute（）添加组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-setattribute（）添加组件"}},[e._v("#")]),e._v(" 使用.setAttribute（）添加组件")]),e._v(" "),a("p",[e._v("要添加组件，可以使用.setAttribute（componentName，data）。让我们向实体添加一个几何组件。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("entityEl.setAttribute('geometry', {\n  primitive: 'box',\n  height: 3,\n  width: 1\n});\n")])])]),a("p",[e._v("或者添加社区物理组件：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("entityEl.setAttribute('dynamic-body', {\n  shape: 'box',\n  mass: 1.5,\n  linearDamping: 0.005\n});\n")])])]),a("p",[e._v("与普通的HTML.setAttribute（）不同，实体的.setAttribute（）被改进为接受各种类型的参数（如对象），或者能够更新组件的单个属性。阅读有关Entity.setAttribute（）的更多信息。")]),e._v(" "),a("h2",{attrs:{id:"使用-setattribute（）更新组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-setattribute（）更新组件"}},[e._v("#")]),e._v(" 使用.setAttribute（）更新组件")]),e._v(" "),a("p",[e._v("要更新组件，我们还使用.setAttribute（）。更新组件有几种形式。")]),e._v(" "),a("h3",{attrs:{id:"更新单个属性组件的属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新单个属性组件的属性"}},[e._v("#")]),e._v(" 更新单个属性组件的属性")]),e._v(" "),a("p",[e._v("让我们更新position组件的属性，一个属性组件。我们可以传递对象或字符串。稍微倾向于传递一个对象，这样A-Frame就不必解析字符串。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("entityEl.setAttribute('position', {x: 1, y: 2, z: -3});\n// Read on to see why `entityEl.object3D.position.set(1, 2, -3)` is preferred though.\n")])])]),a("h3",{attrs:{id:"更新多属性组件的单个属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新多属性组件的单个属性"}},[e._v("#")]),e._v(" 更新多属性组件的单个属性")]),e._v(" "),a("p",[e._v("让我们更新材质组件的单个属性，一个多属性组件。我们通过向.setAttribute（）提供组件名、属性名和属性值来完成此操作：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("entityEl.setAttribute('material', 'color', 'red');\n\n")])])]),a("h3",{attrs:{id:"更新多属性组件的多属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新多属性组件的多属性"}},[e._v("#")]),e._v(" 更新多属性组件的多属性")]),e._v(" "),a("p",[e._v("让我们一次更新灯光组件的多个属性，一个多属性组件。我们通过向.setAttribute（）提供组件名和属性对象来实现这一点。我们将更改灯光的颜色和强度，但保持类型不变：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// <a-entity light=\"type: directional; color: #CAC; intensity: 0.5\"></a-entity>\nentityEl.setAttribute('light', {color: '#ACC', intensity: 0.75});\n// <a-entity light=\"type: directional; color: #ACC; intensity: 0.75\"></a-entity>\n")])])]),a("h3",{attrs:{id:"更新位置、旋转、缩放和可见。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新位置、旋转、缩放和可见。"}},[e._v("#")]),e._v(" 更新位置、旋转、缩放和可见。")]),e._v(" "),a("p",[e._v("作为特殊情况，为了获得更好的性能、内存和对实用程序的访问，我们建议通过实体的Object3D而不是通过.setAttribute直接在3.js级别修改位置、旋转、缩放和可见：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Examples for position.\nentityEl.object3D.position.set(1, 2, 3);\nentityEl.object3D.position.x += 5;\nentityEl.object3D.position.multiplyScalar(5);\n\n// Examples for rotation.\nentityEl.object3D.rotation.y = THREE.Math.degToRad(45);\nentityEl.object3D.rotation.divideScalar(2);\n\n// Examples for scale.\nentityEl.object3D.scale.set(2, 2, 2);\nentityEl.object3D.scale.z += 1.5;\n\n// Examples for visible.\nentityEl.object3D.visible = false;\nentityEl.object3D.visible = true;\n")])])]),a("p",[e._v("这使我们可以跳过.setAttribute开销，而是为最常更新的组件进行简单的属性设置。在执行例如entityEl.getAttribute（'position'）；的操作时，仍然会反映3.js级别的更新；。")]),e._v(" "),a("h3",{attrs:{id:"替换多属性组件的属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#替换多属性组件的属性"}},[e._v("#")]),e._v(" 替换多属性组件的属性")]),e._v(" "),a("p",[e._v("让我们替换几何体组件的所有属性，一个多属性组件。我们通过提供组件名、属性的对象到.setAttribute（）和指定清除现有属性的标志来实现。我们将用新属性替换几何体的所有现有属性：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// <a-entity geometry=\"primitive: cylinder; height: 4; radius: 2\"></a-entity>\nentityEl.setAttribute('geometry', {primitive: 'torusKnot', p: 1, q: 3, radiusTubular: 4}, true);\n// <a-entity geometry=\"primitive: torusKnot; p: 1; q: 3; radiusTubular: 4\"></a-entity>\n\n")])])]),a("h2",{attrs:{id:"使用-removeattribute（）删除组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-removeattribute（）删除组件"}},[e._v("#")]),e._v(" 使用.removeAttribute（）删除组件")]),e._v(" "),a("p",[e._v("要从实体中移除或分离组件，可以使用.removeAttribute（componentName）。让我们从camera实体中移除默认的wasd控件：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var cameraEl = document.querySelector('[camera]');\ncameraEl.removeAttribute('wasd-controls');\n")])])]),a("h2",{attrs:{id:"事件和事件侦听器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件和事件侦听器"}},[e._v("#")]),e._v(" 事件和事件侦听器")]),e._v(" "),a("p",[e._v("有了JavaScript和DOM，实体和组件可以很容易地相互通信：事件和事件监听器。事件是一种发送信号的方式，其他代码可以接收并响应该信号。阅读有关浏览器事件的更多信息。")]),e._v(" "),a("h3",{attrs:{id:"使用-emit（）发出事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-emit（）发出事件"}},[e._v("#")]),e._v(" 使用.emit（）发出事件")]),e._v(" "),a("p",[e._v("A-Frame元素提供了使用.emit（eventName、eventDetail、bubbles）发出自定义事件的简单方法。例如，假设我们正在构建一个物理组件，我们希望该实体在与另一个实体碰撞时发出信号：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("entityEl.emit('physicscollided', {collidingEntity: anotherEntityEl}, false);\n\n")])])]),a("p",[e._v("然后，代码的其他部分可以等待并侦听此事件并运行响应代码。我们可以通过事件细节作为第二个参数传递信息和数据。我们可以指定事件是否冒泡，这意味着父实体也将发出事件。所以代码的其他部分可以注册一个事件侦听器。")]),e._v(" "),a("h3",{attrs:{id:"使用-addeventlistener（）添加事件侦听器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-addeventlistener（）添加事件侦听器"}},[e._v("#")]),e._v(" 使用.addEventListener（）添加事件侦听器")]),e._v(" "),a("p",[e._v("与普通HTML元素一样，我们可以使用.addEventListener（eventName，function）注册事件侦听器。当发出侦听器注册到的事件时，将调用该函数并处理该事件。例如，从上一个示例继续物理碰撞事件：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("entityEl.addEventListener('physicscollided', function (event) {\n  console.log('Entity collided with', event.detail.collidingEntity);\n});\n\n")])])]),a("p",[e._v("当实体发出physiccolled事件时，将使用event对象调用该函数。特别是在event对象中，我们有一个event细节，它包含通过事件传递的数据和信息。")]),e._v(" "),a("h3",{attrs:{id:"使用-removeeventlistener（）删除事件侦听器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-removeeventlistener（）删除事件侦听器"}},[e._v("#")]),e._v(" 使用.removeEventListener（）删除事件侦听器")]),e._v(" "),a("p",[e._v("与普通的HTML元素一样，当我们要删除事件侦听器时，可以使用.remove event listener（eventName，function）。我们必须传递侦听器注册时使用的相同事件名和函数。例如，从上一个示例继续物理碰撞事件：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// We have to define this function with a name if we later remove it.\nfunction collisionHandler (event) {\n  console.log('Entity collided with', event.detail.collidingEntity);\n}\n\nentityEl.addEventListener('physicscollided', collisionHandler);\nentityEl.removeEventListener('physicscollided', collisionHandler);\n")])])]),a("h2",{attrs:{id:"注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[e._v("#")]),e._v(" 注意事项")]),e._v(" "),a("p",[e._v("A-Frame实体和原语的实现方式有利于提高性能，因此某些HTML api可能无法按预期工作。例如，当一个实体的组件被改变时，包含值的属性选择器将不起作用，变异观察者也不会触发改变。")])])}),[],!1,null,null,null);t.default=r.exports}}]);