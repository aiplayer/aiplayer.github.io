(window.webpackJsonp=window.webpackJsonp||[]).push([[128],{279:function(t,n,e){"use strict";e.r(n);var a=e(28),s=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"物理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#物理"}},[t._v("#")]),t._v(" 物理")]),t._v(" "),e("p",[t._v("在本教程中，我们将实验nunuStudio中物理学的工作原理，在编辑器中将物理学表示为对象，物理对象没有直观的表示，它们仅用于物理模拟。")]),t._v(" "),e("p",[t._v("nunuStudio中的物理由schteppe开发的cannon.js支持，有关物理引擎的更多信息，请访问http://www.cannonjs.org/。")]),t._v(" "),e("p",[t._v("nunuStudio将物理实体封装在对象中，这些实体在场景的基础上进行管理和更新，物理配置由场景管理。")]),t._v(" "),e("h2",{attrs:{id:"物理对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#物理对象"}},[t._v("#")]),t._v(" 物理对象")]),t._v(" "),e("p",[t._v("要添加物理对象，请在左侧工具栏中选择所需的物理对象，然后将其添加到场景中，然后添加一个网格对象作为新创建的物理对象的子对象，以使其在场景中可见。不要忘记添加一个地面对象，以使其他物理对象不会掉出屏幕。")]),t._v(" "),e("p",[t._v("物理对象可以配置为动态，静态或运动学对象。动态对象会动态更新并检测碰撞，运动对象仅根据其速度进行更新，而静态对象则完全不会更新。静态对象的行为就像墙壁或地板。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/physical/vedio.mp4",alt:"alt text"}})]),t._v(" "),e("h2",{attrs:{id:"对象定位"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象定位"}},[t._v("#")]),t._v(" 对象定位")]),t._v(" "),e("p",[t._v("有一个模式属性，指示物理坐标是如何从物理世界转换为场景的，物理世界不考虑应用于对象的父级转换，世界定位用于快速复制物理世界到对象的世界坐标并且坐标将匹配存储在物理体内的值。有时将物理对象存储在层次结构中很有用，可以使用局部定位来适应物理世界坐标以匹配场景，它对性能的影响很小，并且物理坐标将不匹配对象的局部变换。")]),t._v(" "),e("p",[t._v("在下面，我们对对象层次结构中的世界物理对象和本地物理对象进行了比较。正如我们可以观察到的那样，本地定位对象的行为符合我们的预期。")]),t._v(" "),e("p",[t._v("您也可以在此处下载示例项目文件，或直接在Web编辑器中打开它。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/physical/run.png",alt:"alt text"}})]),t._v(" "),e("h2",{attrs:{id:"物理对象控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#物理对象控制"}},[t._v("#")]),t._v(" 物理对象控制")]),t._v(" "),e("p",[t._v("要使用便签纸与物理对象进行交互，我们需要将物理主体附加到该对象。然后，我们可以访问每个物理对象中存在的身体属性，并更改力，加速度和速度值以使其在场景中移动。")]),t._v(" "),e("p",[t._v("以下代码获取了一个物理对象主体，并使用键盘WASD键和空格键向该主体添加了速度，以迫使多维数据集移动。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var body;\n\nthis.initialize = function()\n{\n\tbody = scene.getObjectByName("physics").body;\n};\n\nthis.update = function()\n{\n\tif(Keyboard.keyPressed(Keyboard.A))\n\t{\n\t\tbody.velocity.x -= 0.2;\n\t}\n\tif(Keyboard.keyPressed(Keyboard.D))\n\t{\n\t\tbody.velocity.x += 0.2;\n\t}\n\tif(Keyboard.keyPressed(Keyboard.W))\n\t{\n\t\tbody.velocity.z -= 0.2;\n\t}\n\tif(Keyboard.keyPressed(Keyboard.S))\n\t{\n\t\tbody.velocity.z += 0.2;\n\t}\n\t\n\tif(Keyboard.keyJustPressed(Keyboard.SPACEBAR))\n\t{\n\t\tbody.velocity.y += 5;\n\t}\n};\n')])])]),e("p",[t._v("可以看到上面显示的代码在一个物理多维数据集下运行，使用WASD键控制该多维数据集，并使用空格键使该多维数据集跳转。即使我们没有为立方体指定旋转，物理引擎也会根据立方体表面和地板之间的摩擦力自动计算旋转角度。正如我们可以看到的那样，立方体自然围绕场景旋转。")]),t._v(" "),e("p",[t._v("您也可以在此处下载示例项目文件，或直接在Web编辑器中打开它。\n"),e("img",{attrs:{src:"/nunustudio/physical/run2.png",alt:"alt text"}})])])}),[],!1,null,null,null);n.default=s.exports}}]);