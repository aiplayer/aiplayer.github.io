(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{394:function(t,a,e){"use strict";e.r(a);var n=e(28),s=Object(n.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"构建minecraft原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构建minecraft原型"}},[t._v("#")]),t._v(" 构建MineCraft原型")]),t._v(" "),e("p",[t._v("让我们来构建一个基本的Minecraft（体素构建器）演示，目标是带有控制器的房间级虚拟现实（例如，Vive，Rift）。该示例在移动和桌面上的可用性最低。")]),t._v(" "),e("h2",{attrs:{id:"骨架示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#骨架示例"}},[t._v("#")]),t._v(" 骨架示例")]),t._v(" "),e("p",[t._v("我们将从这个框架HTML开始：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script src="https://aframe.io/releases/1.0.4/aframe.min.js"><\/script>\n\n<body>\n  <a-scene>\n  </a-scene>\n</body>\n\n')])])]),e("h2",{attrs:{id:"添加地面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#添加地面"}},[t._v("#")]),t._v(" 添加地面")]),t._v(" "),e("a-plane",[t._v("和"),e("a-circle",[t._v("是常用于添加地面的基本基元。我们将使用"),e("a-collinder",[t._v("来更好地使用我们的控制器将使用的光线投射器。圆柱体的半径为30米，与我们稍后将添加的天空半径相匹配。请注意，A帧单位以米为单位，以匹配从WebVR API返回的实际单位。\n"),e("p",[t._v("我们将使用的地面纹理位于https://cdn.aframe.io/a-painter/images/floor.jpg”。我们将向资源添加纹理，并创建指向该纹理的细圆柱体实体：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script src="https://aframe.io/releases/1.0.4/aframe.min.js"><\/script>\n\n<a-scene>\n  <a-cylinder id="ground" src="https://cdn.aframe.io/a-painter/images/floor.jpg" radius="32" height="0.1"></a-cylinder>\n</a-scene>\n')])])]),e("h2",{attrs:{id:"预加载资产"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#预加载资产"}},[t._v("#")]),t._v(" 预加载资产")]),t._v(" "),e("p",[t._v("通过src属性指定URL将在运行时加载纹理。由于网络请求会对渲染性能产生负面影响，因此我们可以预加载纹理，以便场景在获取其资源之前不会开始渲染。我们可以使用资产管理系统来完成这项工作。")]),t._v(" "),e("p",[t._v("我们将"),e("a-assets",[t._v("放置到"),e("a-scene",[t._v("中，将资源（如图像、视频、模型、声音）放置到"),e("a-assets",[t._v("中，并通过选择器（如myTexture）从实体指向它们。")])],1)],1)],1),t._v(" "),e("p",[t._v("让我们使用"),e("img"),t._v("元素将地面纹理移动到"),e("a-assets",[t._v("以进行预加载：")])],1),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script src="https://aframe.io/releases/1.0.4/aframe.min.js"><\/script>\n\n<a-scene>\n  <a-assets>\n    <img id="groundTexture" src="https://cdn.aframe.io/a-painter/images/floor.jpg">\n  </a-assets>\n\n  <a-cylinder id="ground" src="#groundTexture" radius="32" height="0.1"></a-cylinder>\n</a-scene>\n')])])]),e("h2",{attrs:{id:"添加背景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#添加背景"}},[t._v("#")]),t._v(" 添加背景")]),t._v(" "),e("p",[t._v("让我们使用"),e("a-sky",[t._v("元素将360°背景添加到"),e("a-scene",[t._v("中。"),e("a-sky",[t._v("是一个大的三维球体，其内部映射有一个材质。与普通图像一样，"),e("a-sky",[t._v("可以使用src进行图像路径。这最终让我们可以用一行HTML制作360°沉浸式图像。作为以后的练习，尝试使用Flickr等矩形池中的一些360°图像。")])],1)],1)],1)],1),t._v(" "),e("p",[t._v("我们可以添加纯色背景（例如"),e("a-sky",{attrs:{color:"“#333”"}}),t._v("）或渐变，但我们可以添加带图像的纹理背景。我们使用的图像位于https://cdn.aframe.io/a-painter/images/sky.jpg。")],1),t._v(" "),e("p",[t._v("我们使用的图像纹理覆盖了半球体，因此我们将使用theta length=“90”将球体切成两半，并将球体的半径设置为30米以匹配地面：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script src="https://aframe.io/releases/1.0.4/aframe.min.js"><\/script>\n\n<a-scene>\n  <a-assets>\n    <img id="groundTexture" src="https://cdn.aframe.io/a-painter/images/floor.jpg">\n    <img id="skyTexture" src="https://cdn.aframe.io/a-painter/images/sky.jpg">\n  </a-assets>\n\n  <a-cylinder id="ground" src="#groundTexture" radius="30" height="0.1"></a-cylinder>\n\n  <a-sky id="background" src="#skyTexture" theta-length="90" radius="30"></a-sky>\n</a-scene>\n')])])]),e("h2",{attrs:{id:"添加体素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#添加体素"}},[t._v("#")]),t._v(" 添加体素")]),t._v(" "),e("p",[t._v("我们的虚拟现实应用程序中的体素类似于"),e("a-box",[t._v("，但附加了一些自定义a-Frame组件。但首先让我们回顾一下实体组件模式。让我们看看如何在引擎盖下组合易于使用的基本体，如"),e("a-box",[t._v("。")])],1)],1),t._v(" "),e("p",[t._v("本节稍后将深入研究一对a-Frame组件的实现。不过，在实践中，我们经常会通过已经由A-Frame社区开发人员编写的HTML使用组件，而不是从头开始构建它们。")]),t._v(" "),e("h2",{attrs:{id:"实体组件模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实体组件模式"}},[t._v("#")]),t._v(" 实体组件模式")]),t._v(" "),e("p",[t._v("A-Frame场景中的每个对象都是"),e("A-entity",[t._v("，它本身不做任何事情，就像一个空的"),e("div",[t._v("。我们将组件（不要与Web或React组件混淆）插入到该实体中，以提供外观、行为和逻辑。")])])],1),t._v(" "),e("p",[t._v("对于长方体，我们附加并配置a形框架的基本几何和材质组件。。下面是"),e("a-box",[t._v("分解为其基本组件的样子。"),e("a-box",[t._v("包装组件：")])],1)],1),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\x3c!-- <a-box color="red" depth="0.5" height="0.5" shader="flat" width="0.5"></a-box> --\x3e\n<a-entity geometry="primitive: box; depth: 0.5; height: 0.5; width 0.5"\n          material="color: red; shader: standard">\n</a-entity>\n')])])]),e("p",[t._v("组件的好处是它们是可组合的。我们可以从一堆现有组件中进行混合和匹配，以构造不同类型的对象。在三维开发中，我们可能构造的对象类型在数量和复杂性上是无限的，我们需要一种简单的方法来定义新的对象类型，而不是通过传统的继承。与此形成对比的是2dweb，我们使用一个固定HTML元素的小池进行开发，并将它们放到一个层次结构中。")]),t._v(" "),e("h2",{attrs:{id:"随机颜色分量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#随机颜色分量"}},[t._v("#")]),t._v(" 随机颜色分量")]),t._v(" "),e("p",[t._v("A-Frame中的组件是用JavaScript定义的，它们可以完全访问3.js和domapi；它们可以做任何事情。我们将所有对象定义为一组组件。")]),t._v(" "),e("p",[t._v("我们将通过编写一个A-Frame组件来设置框上的随机颜色，从而使模式生效。组件注册到AFRAME.registerComponent。我们可以定义一个模式（组件的数据）和生命周期处理程序方法（组件的逻辑）。对于随机颜色组件，我们不会设置模式，因为它是不可配置的。但是我们将定义init处理程序，在附加组件时只调用一次：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("AFRAME.registerComponent('random-color', {\n  init: function () {\n    // ...\n  }\n});\n")])])]),e("p",[t._v("对于随机颜色组件，我们希望在该组件所附加到的实体上设置随机颜色。组件从处理程序方法中引用具有this.el的实体。为了使用JavaScript更改颜色，我们使用.setAttribute（）更改材质组件的颜色属性。A-Frame稍微增强了几个domapi的行为，但这些api大多反映了普通的web开发。阅读有关在A-Frame中使用JavaScript和domapi的更多信息。")]),t._v(" "),e("p",[t._v("我们还将把material组件添加到应该在此之前初始化的组件列表中，这样我们的材料就不会被覆盖。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("AFRAME.registerComponent('random-color', {\n  dependencies: ['material'],\n\n  init: function () {\n    // Set material component's color property to a random color.\n    this.el.setAttribute('material', 'color', getRandomColor());\n  }\n});\n\nfunction getRandomColor() {\n  const letters = '0123456789ABCDEF';\n  var color = '#';\n  for (var i = 0; i < 6; i++ ) {\n    color += letters[Math.floor(Math.random() * 16)];\n  }\n  return color;\n}\n")])])]),e("p",[t._v("组件注册后，我们可以直接从HTML附加此组件。在A-Frame框架中编写的所有代码都是扩展HTML的，这些扩展可以用于其他对象和场景中。最美妙的是，开发人员可以编写一个将物理添加到对象中的组件，然后甚至不知道JavaScript的人可以将物理添加到他们的场景中！")]),t._v(" "),e("p",[t._v("以前面的box实体为例，我们附加了random color HTML属性来插入random color组件。我们将组件保存为JS文件，并在场景之前包含它：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script src="https://aframe.io/releases/1.0.4/aframe.min.js"><\/script>\n<script src="components/random-color.js"><\/script>\n\n<a-scene>\n  <a-assets>\n    <img id="skyTexture" src="https://cdn.aframe.io/a-painter/images/sky.jpg">\n  </a-assets>\n\n  \x3c!-- Box with random color. --\x3e\n  <a-entity geometry="primitive: box; depth: 0.5; height: 0.5; width 0.5"\n            material="shader: standard"\n            position="0 0.5 -2"\n            random-color></a-entity>\n\n  <a-cylinder id="ground" src="#groundTexture" radius="30" height="0.1"></a-cylinder>\n\n  <a-sky id="background" src="#skyTexture" theta-length="90" radius="30"></a-sky>\n</a-scene>\n')])])]),e("p",[t._v("组件可以插入到任何实体中，而不必像在传统继承中那样创建或扩展类。如果我们想附加它说，"),e("a-sphere",[t._v("或"),e("a-obj-model",[t._v("，我们可以！")])],1)],1),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\x3c!-- Reusing and attaching the random color component to other entities. --\x3e\n<a-sphere random-color></a-sphere>\n<a-obj-model src="model.obj" random-color></a-obj-model>\n')])])]),e("p",[t._v("如果我们想让其他人使用这个组件，我们也可以。我们从A-Frame注册中心的生态系统中提取了许多方便的组件，类似于Unity资产存储。如果我们使用组件开发我们的应用程序，那么我们所有的代码都是固有的模块化和可重用的！")]),t._v(" "),e("h2",{attrs:{id:"捕捉组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#捕捉组件"}},[t._v("#")]),t._v(" 捕捉组件")]),t._v(" "),e("p",[t._v("我们将有一个捕捉组件来将我们的框捕捉到网格，这样它们就不会重叠。我们不会详细介绍这个组件是如何实现的，但是您可以查看snap组件的源代码（20行JavaScript）。")]),t._v(" "),e("p",[t._v("我们将捕捉组件附加到长方体上，使其每半米捕捉一次，并偏移长方体的中心：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<a-entity\n   geometry="primitive: box; height: 0.5; width: 0.5; depth: 0.5"\n   material="shader: standard"\n   random-color\n   snap="offset: 0.25 0.25 0.25; snap: 0.5 0.5 0.5">\n   \t\n</a-entity>\n')])])]),e("p",[t._v("现在我们有了一个长方体实体，表示为一个组件束，可以用来描述场景中的所有体素。")]),t._v(" "),e("h2",{attrs:{id:"混音"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#混音"}},[t._v("#")]),t._v(" 混音")]),t._v(" "),e("p",[t._v("我们可以创建一个mixin来定义一个可重用的组件包。我们将使用"),e("a-mixin",[t._v("来描述它，而不是将对象添加到场景中的"),e("a-entity",[t._v("，该"),e("a-mixin",[t._v("可以重复使用来创建体素，如预制体：")])],1)],1)],1),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script src="https://aframe.io/releases/1.0.4/aframe.min.js"><\/script>\n<script src="components/random-color.js"><\/script>\n<script src="components/snap.js"><\/script>\n\n<a-scene>\n  <a-assets>\n    <img id="groundTexture" src="https://cdn.aframe.io/a-painter/images/floor.jpg">\n    <img id="skyTexture" src="https://cdn.aframe.io/a-painter/images/sky.jpg">\n    <a-mixin id="voxel"\n       geometry="primitive: box; height: 0.5; width: 0.5; depth: 0.5"\n       material="shader: standard"\n       random-color\n       snap="offset: 0.25 0.25 0.25; snap: 0.5 0.5 0.5"></a-mixin>\n  </a-assets>\n\n  <a-cylinder id="ground" src="#groundTexture" radius="30" height="0.1"></a-cylinder>\n\n  <a-sky id="background" src="#skyTexture" theta-length="90" radius="30"></a-sky>\n\n  <a-entity mixin="voxel" position="-1 0 -2"></a-entity>\n  <a-entity mixin="voxel" position="0 0 -2"></a-entity>\n  <a-entity mixin="voxel" position="0 1 -2">\n    <a-animation attribute="rotation" to="0 360 0" repeat="indefinite"></a-animation>\n  </a-entity>\n  <a-entity mixin="voxel" position="1 0 -2"></a-entity>\n</a-scene>\n')])])]),e("p",[t._v("我们用这个混合体添加了体素：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<a-entity mixin="voxel" position="-1 0 -2"></a-entity>\n<a-entity mixin="voxel" position="0 0 -2"></a-entity>\n<a-entity mixin="voxel" position="0 1 -2">\n  <a-animation attribute="rotation" to="0 360 0" repeat="indefinite"></a-animation>\n</a-entity>\n<a-entity mixin="voxel" position="1 0 -2"></a-entity>\n')])])]),e("p",[t._v("接下来，我们将使用跟踪控制器通过交互动态创建体素。让我们开始在应用程序中添加人手。")]),t._v(" "),e("h2",{attrs:{id:"添加手动控制器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#添加手动控制器"}},[t._v("#")]),t._v(" 添加手动控制器")]),t._v(" "),e("p",[t._v("添加HTC Vive或Oculus触摸跟踪控制器很容易：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\x3c!-- Vive. --\x3e\n<a-entity vive-controls="hand: left"></a-entity>\n<a-entity vive-controls="hand: right"></a-entity>\n\n\x3c!-- Or Rift. --\x3e\n<a-entity oculus-touch-controls="hand: left"></a-entity>\n<a-entity oculus-touch-controls="hand: right"></a-entity>\n')])])]),e("p",[t._v("我们将使用手控，它抽象并与Vive和Rift控件一起工作，提供基本手的模型。我们会让左手负责传送，右手负责产卵和放置积木。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<a-entity id="teleHand" hand-controls="left"></a-entity>\n<a-entity id="blockHand" hand-controls="right"></a-entity>\n')])])]),e("h2",{attrs:{id:"增加传送到左手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#增加传送到左手"}},[t._v("#")]),t._v(" 增加传送到左手")]),t._v(" "),e("p",[t._v("我们将在左手边插入隐形传送功能，这样我们就可以按住一个按钮来显示从控制器出来的弧线，然后松开按钮来隐形传送到弧线的末端。之前，我们编写了自己的A形框架组件。但是我们也可以使用已经从社区制作的开源组件，直接从HTML使用它们！")]),t._v(" "),e("p",[t._v("对于远程传输，有一个由@fernandojsg提供的远程传输控制组件。在自述文件之后，我们通过"),e("code",[t._v("<script>")]),t._v("标签添加组件，并在实体上的控制器上设置teleport controls组件：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script src="https://aframe.io/releases/1.0.4/aframe.min.js"><\/script>\n<script src="https://unpkg.com/aframe-teleport-controls@0.2.x/dist/aframe-teleport-controls.min.js"><\/script>\n\n\x3c!-- ... --\x3e\n\n<a-entity id="teleHand" hand-controls="left" teleport-controls></a-entity>\n<a-entity id="blockHand" hand-controls="right"></a-entity>\n')])])]),e("p",[t._v("然后我们将配置远程传输控制组件以使用弧形远程传输。默认情况下，远程传输控件将仅在地面上进行远程传输，但我们可以指定使用collisionEntities在块和地面上使用选择器进行远程传输。这些属性是创建teleport控件组件时使用的API的一部分：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<a-entity id="teleHand" hand-controls="left" teleport-controls="type: parabolic; collisionEntities: [mixin=\'voxel\'], #ground"></a-entity>\n\n')])])]),e("p",[t._v("就这样！一个脚本标签和一个HTML属性，我们可以传送。有关更酷的组件，请查看A-Frame注册表。")]),t._v(" "),e("h2",{attrs:{id:"将体素产卵器添加到右侧"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#将体素产卵器添加到右侧"}},[t._v("#")]),t._v(" 将体素产卵器添加到右侧")]),t._v(" "),e("p",[t._v("在WebVR中，单击对象的功能并不像在2D应用程序中那样是内置的。我们必须自己提供。幸运的是，A-Frame有许多组件来处理交互。在虚拟现实中，像光标一样点击的一种常用方法是使用光线投射器，一种能够射出并返回与之相交的对象的激光。然后，我们通过监听交互事件并检查raycaster的交集来实现光标状态。")]),t._v(" "),e("p",[t._v("A-Frame为控制器激光交互提供激光控制组件，将点击激光连接到虚拟现实跟踪控制器。像teleport控件组件一样，我们包含脚本标记并附加激光控件组件。这次是右手边：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script src="https://aframe.io/releases/1.0.4/aframe.min.js"><\/script>\n<script src="https://unpkg.com/aframe-teleport-controls@0.2.x/dist/aframe-teleport-controls.min.js"><\/script>\n\n\x3c!-- ... --\x3e\n\n<a-entity id="teleHand" hand-controls="left" teleport-controls="type: parabolic; collisionEntities: [mixin=\'voxel\'], #ground"></a-entity>\n<a-entity id="blockHand" hand-controls="right" laser-controls></a-entity>\n')])])]),e("p",[t._v("现在，当我们按下被跟踪控制器上的触发按钮时，激光控制将在控制器和它当时相交的实体上发出一个点击事件。还提供了mouseenter、mouseleave等事件。事件包含有关交叉点的详细信息。")]),t._v(" "),e("p",[t._v("这为我们提供了单击的能力，但是我们必须连接一些代码来处理这些单击以生成块。我们可以使用事件侦听器和document.createElement：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("document.querySelector('#blockHand').addEventListener(`click`, function (evt) {\n  // Create a blank entity.\n  var newVoxelEl = document.createElement('a-entity');\n\n  // Use the mixin to make it a voxel.\n  newVoxelEl.setAttribute('mixin', 'voxel');\n\n  // Set the position using intersection point. The `snap` component above which\n  // is part of the mixin will snap it to the closest half meter.\n  newVoxelEl.setAttribute('position', evt.detail.intersection.point);\n\n  // Add to the scene with `appendChild`.\n  this.appendChild(newVoxelEl);\n});\n")])])]),e("p",[t._v("为了泛化从交叉点事件创建实体，我们创建了一个交叉点派生组件，该组件可以配置为任何事件和属性列表。我们不会详细介绍实现的细节，但是您可以在GitHub上查看简单的intersection spawn组件源代码。我们将交叉点生成功能附加到右侧：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<a-entity id="blockHand" hand-controls="right" laser-controls intersection-spawn="event: click; mixin: voxel"></a-entity>\n\n')])])]),e("p",[t._v("现在，当我们点击，我们产生体素！")]),t._v(" "),e("h2",{attrs:{id:"添加对移动和桌面的支持"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#添加对移动和桌面的支持"}},[t._v("#")]),t._v(" 添加对移动和桌面的支持")]),t._v(" "),e("p",[t._v("我们看到如何通过混合组件来构建一个自定义类型的对象（即，一个具有点击功能并在点击时生成块的手模型的跟踪手控制器）。组件的美妙之处在于它们可以在其他上下文中重用。我们甚至可以将交叉点生成组件附加到基于凝视的光标组件，这样我们也可以在移动和桌面上生成块，而不必更改组件的任何内容！")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<a-entity id="blockHand" hand-controls="right" laser-controls intersection-spawn="event: click; mixin: voxel"></a-entity>\n\n<a-camera>\n  <a-cursor intersection-spawn="event: click; mixin: voxel"></a-cursor>\n</a-camera>\n')])])])])],1)],1)],1)}),[],!1,null,null,null);a.default=s.exports}}]);