(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{321:function(e,t,n){"use strict";n.r(t);var a=n(28),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"how-to-handle-click-events-on-ar-js"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#how-to-handle-click-events-on-ar-js"}},[e._v("#")]),e._v(" How to handle click events on AR.js")]),e._v(" "),n("p",[e._v("Showing AR content on a website is nice, but adding user interaction opens a completely new world of opportunities.")]),e._v(" "),n("p",[e._v("In the past articles I wrote about AR.js and the way we can deliver AR content only with a QR-Code. But what about interacting with 3D objects, that we can already show to the user? This will open a new world of applications for this wonderful technology.\nA brief search on AR.js Github repository shows several event-related issues, most of them not solved. AR.js is built at the top of aframe and itâ€™s not easy to understand how to handle simple events on 3D objects, i.e. click events.\nI tried to collect all the working hints that I found and organize them into this article that comes with full working example of an user-interaction click.\nSo, letâ€™s start!")]),e._v(" "),n("h2",{attrs:{id:"create-the-html-entry-point"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#create-the-html-entry-point"}},[e._v("#")]),e._v(" Create the HTML entry point")]),e._v(" "),n("p",[e._v("As always, an AR.js app starts with an HTML file that defines markers, models, and so on. In this file, in order to handle events, we need to define additional properties on elements. Letâ€™s see them in detail.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<!doctype HTML>\n<html>\n    <head>\n        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">\n    </head>\n    <script src="https://aframe.io/releases/0.9.0/aframe.min.js"><\/script>\n    <script src="https://rawgit.com/jeromeetienne/AR.js/master/aframe/build/aframe-ar.min.js"><\/script>\n    <script src="https://rawgit.com/donmccurdy/aframe-extras/master/dist/aframe-extras.loaders.min.js"><\/script>\n    \n    \x3c!-- import events.js script --\x3e\n    <script src="https://rawgit.com/nicolocarpignoli/nicolocarpignoli.github.io/master/ar-click-events/events.js"><\/script>\n    \n    <body style=\'margin : 0px; overflow: hidden;\'>\n        \x3c!-- we add detectionMode and matrixCodeType to tell AR.js to recognize barcode markers --\x3e\n        <a-scene embedded arjs=\'sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;\'>\n\n        <a-assets>\n            <a-asset-item id="animated-asset" src="https://raw.githubusercontent.com/nicolocarpignoli/nicolocarpignoli.github.io/master/ar-click-events/models/CesiumMan.gltf"></a-asset-item>\n        </a-assets>\n\n        <a-marker markerhandler emitevents="true" cursor="rayOrigin: mouse" id="animated-marker" type=\'barcode\' value=\'6\'>\n            <a-entity\n                id="animated-model"\n                gltf-model="#animated-asset"\n                scale="2">\n            </a-entity>\n        </a-marker>\n\n        \x3c!-- use this <a-entity camera> to support multiple-markers, otherwise use <a-marker-camera> instead of </a-marker> --\x3e\n        <a-entity camera></a-entity>\n        </a-scene>\n    </body>\n</html>\n')])])]),n("ul",[n("li",[e._v("At line 10, we import an external Javascript file used for setting the event handler. Weâ€™ll see it later in detail")]),e._v(" "),n("li",[e._v("At line 21, our marker is defined with additional properties: markerhandler is used as the registered component name, while emitevents and cursor define the possibility to emit events, specifically mouse/touch based")]),e._v(" "),n("li",[e._v("Itâ€™s important to define an id or adding a very specific CSS class in order to retrieve our marker and entity elements later.")])]),e._v(" "),n("p",[e._v("Letâ€™s see how our "),n("code",[e._v("events.js")]),e._v(" file looks")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("AFRAME.registerComponent('markerhandler', {\n\n    init: function() {\n        const animatedMarker = document.querySelector(\"#animated-marker\");\n        const aEntity = document.querySelector(\"#animated-model\");\n\n        // every click, we make our model grow in size :)\n        animatedMarker.addEventListener('click', function(ev, target){\n            const intersectedElement = ev && ev.detail && ev.detail.intersectedEl;\n            if (aEntity && intersectedElement === aEntity) {\n                const scale = aEntity.getAttribute('scale');\n                Object.keys(scale).forEach((key) => scale[key] = scale[key] + 1);\n                aEntity.setAttribute('scale', scale);\n            }\n        });\n}});\n")])])]),n("p",[e._v("I already commented inline, and code is pretty self-explained: we register our component and, at the initialization, we add an event listener at â€˜clickâ€™.\nAt line 10 I added an extra check: in fact, without that check events are firing multiple times, one for marker and one for entity. With this check we respond to an event only when cursorEl, our marker element, is visibile and is the element associated to the event.\nThatâ€™s it! Once inside the event listener you can do whatever you want; I make the 3D model growing bigger each click. You can surely do something more interesting and useful than that ðŸ˜ƒ\nEdit: Iâ€™m currently working to make this article updated to new a-frame versions and to answer to all of you asking for details about this topic. Stay tuned!")])])}),[],!1,null,null,null);t.default=i.exports}}]);