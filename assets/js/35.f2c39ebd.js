(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{332:function(t,e,a){"use strict";a.r(e);var r=a(28),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"光标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#光标"}},[t._v("#")]),t._v(" 光标")]),t._v(" "),a("p",[t._v("光标组件在raycaster组件的顶部提供鼠标悬停和单击状态以进行交互。游标组件既可以用于基于凝视的交互，也可以用于基于控制器的交互，但是需要根据用例配置外观。该"),a("a-cursor",[t._v(" 原语为基于凝视的光标提供默认的标线外观，并且激光控制组件为所有控制器配置光标。")])],1),t._v(" "),a("p",[t._v("光标组件监听事件和不断什么正在徘徊，并以提供按下状态mousedown，mouseup，mouseenter， mouseleave，和click事件。我们现在使用该名称mouse来模仿传统的Web开发。在幕后，光标组件使用raycaster-intersection和raycaster-intersection-cleared事件，捕获最接近的可见相交实体。")]),t._v(" "),a("p",[t._v("默认情况下，光标配置为在基于凝视的模式下使用，并将通过鼠标或触摸注册用户输入。指定downEvents和 upEvents属性，可使光标与控制器一起使用。例如，激光控制组件会自动配置这些属性以与大多数控制器一起使用。")]),t._v(" "),a("p",[t._v("要为光标提供形状或外观，我们应该应用 几何形状和材质组件，或者使用raycaster组件的showLine属性使用line组件绘制一条线。")]),t._v(" "),a("h2",{attrs:{id:"例子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[t._v("#")]),t._v(" 例子")]),t._v(" "),a("p",[t._v("例如，我们可以创建一个固定在屏幕中央的环形光标。为了将光标固定在屏幕上，以便无论我们在何处都可以看到光标，我们将其放置为活动相机 实体的子级。通过将其放置在Z轴负轴上，将其拉到相机的前面。当光标在框上单击时，我们可以监听click事件。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity camera look-controls>\n  <a-entity cursor="fuse: true; fuseTimeout: 500"\n            position="0 0 -1"\n            geometry="primitive: ring; radiusInner: 0.02; radiusOuter: 0.03"\n            material="color: black; shader: flat">\n  </a-entity>\n</a-entity>\n\n<a-entity id="box" cursor-listener geometry="primitive: box" material="color: blue"></a-entity>\n    \n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// Component to change to a sequential color on click.\nAFRAME.registerComponent('cursor-listener', {\n  init: function () {\n    var lastIndex = -1;\n    var COLORS = ['red', 'green', 'blue'];\n    this.el.addEventListener('click', function (evt) {\n      lastIndex = (lastIndex + 1) % COLORS.length;\n      this.setAttribute('material', 'color', COLORS[lastIndex]);\n      console.log('I was clicked at: ', evt.detail.intersection.point);\n    });\n  }\n});\n\n")])])]),a("h2",{attrs:{id:"特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("属性")]),t._v(" "),a("th",[t._v("描述")]),t._v(" "),a("th",[t._v("默认值")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("downEvents")]),t._v(" "),a("td",[t._v("对实体的附加事件的阵列，以收听到用于触发mousedown（例如，triggerdown对于万岁-对照）。")]),t._v(" "),a("td",[t._v("[]")])]),t._v(" "),a("tr",[a("td",[t._v("fuse")]),t._v(" "),a("td",[t._v("光标是否基于保险丝。")]),t._v(" "),a("td",[t._v("在桌面设备上为false，在移动设备上为true")])]),t._v(" "),a("tr",[a("td",[t._v("fuseTimeout")]),t._v(" "),a("td",[t._v("触发基于保险丝的点击事件之前要等待的时间（以毫秒为单位）。")]),t._v(" "),a("td",[t._v("1500")])]),t._v(" "),a("tr",[a("td",[t._v("mouseCursorStylesEnabled")]),t._v(" "),a("td",[t._v("将鼠标rayOrigin: mouse悬停在实体上时是否在模式下显示指针光标。")]),t._v(" "),a("td",[t._v("true")])]),t._v(" "),a("tr",[a("td",[t._v("rayOrigin")]),t._v(" "),a("td",[t._v("交集射线投射到的位置（即实体或鼠标）。rayOrigin: mouse对于在鼠标和键盘上进行VR开发非常有用。")]),t._v(" "),a("td",[t._v("实体")])]),t._v(" "),a("tr",[a("td",[t._v("upEvents")]),t._v(" "),a("td",[t._v("实体上要监听以触​​发mouseup（例如，trackpadup用于白日梦控件）的其他事件的数组。")]),t._v(" "),a("td",[t._v("[]")])])])]),t._v(" "),a("p",[t._v("为了进一步自定义光标组件，我们配置了光标的依赖组件raycaster组件。")]),t._v(" "),a("h2",{attrs:{id:"事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件"}},[t._v("#")]),t._v(" 事件")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("事件")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("click")]),t._v(" "),a("td",[t._v("如果单击当前相交的实体（无论是通过鼠标还是通过保险丝），则在光标和相交的实体上均发出。")])]),t._v(" "),a("tr",[a("td",[t._v("fusing")]),t._v(" "),a("td",[t._v("当基于保险丝的光标开始递减计数时，在光标和相交的实体上均发出。")])]),t._v(" "),a("tr",[a("td",[t._v("mousedown")]),t._v(" "),a("td",[t._v("在canvas元素上的鼠标按下时在光标和相交的实体（如果有）上均发出。")])]),t._v(" "),a("tr",[a("td",[t._v("mouseenter")]),t._v(" "),a("td",[t._v("当光标与实体相交时，在光标和相交的实体（如果有）上均发出。")])]),t._v(" "),a("tr",[a("td",[t._v("mouseleave　｜\t当光标不再与先前相交的实体相交时，在光标和相交的实体（如果有）上均发出。")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("mouseup｜在canvas元素上的mouseup上的光标和相交的实体（如果有）上都发出。")]),t._v(" "),a("td")])])]),t._v(" "),a("h3",{attrs:{id:"交叉口数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#交叉口数据"}},[t._v("#")]),t._v(" 交叉口数据")]),t._v(" "),a("p",[t._v("相关事件将包含在事件detail中intersection，该细节将包含{distance, point, face, faceIndex, indices, object}有关交叉点的特定数据：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("this.el.addEventListener('click', function (evt) {\n  console.log(evt.detail.intersection.point);\n});\n\n")])])]),a("h2",{attrs:{id:"状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态"}},[t._v("#")]),t._v(" 状态")]),t._v(" "),a("p",[t._v("游标将在某些事件上向游标实体添加状态：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("状态")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("cursor-fusing")]),t._v(" "),a("td",[t._v("当光标在另一个实体上融合时添加。")])]),t._v(" "),a("tr",[a("td",[t._v("cursor-hovering")]),t._v(" "),a("td",[t._v("当光标悬停在另一个实体上时添加。")])])])]),t._v(" "),a("p",[t._v("游标将在某些事件上向相交的实体添加状态：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("状态")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("cursor-hovered")]),t._v(" "),a("td",[t._v("当光标悬停在相交的实体上时添加到该实体。")])])])]),t._v(" "),a("h2",{attrs:{id:"通过raycaster组件配置光标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过raycaster组件配置光标"}},[t._v("#")]),t._v(" 通过Raycaster组件配置光标")]),t._v(" "),a("p",[t._v("光标建立在raycaster组件之上，并取决于它。如果要自定义光标的射线投射片段，可以通过更改raycaster组件属性来完成。假设我们要设置最大距离，不那么频繁地检查相交，并设置可点击的对象：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity cursor raycaster="far: 20; interval: 1000; objects: .clickable"></a-entity>\n\n')])])]),a("h2",{attrs:{id:"基于保险丝的光标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于保险丝的光标"}},[t._v("#")]),t._v(" 基于保险丝的光标")]),t._v(" "),a("p",[t._v("也称为基于凝视的光标。如果我们将光标设置为基于保险丝，则当用户凝视实体一段时间后，光标将触发点击。想象一下，一条激光束缚在用户的头上，然后激光束延伸到场景中。如果用户注视实体足够长的时间（即 fuseTimeout），则光标将触发单击。")]),t._v(" "),a("p",[t._v("基于VR的基于保险丝的交互的优势在于，除了头戴式耳机外，它不需要额外的输入设备。基于保险丝的光标主要用于Google Cardboard应用程序。基于保险丝的交互的缺点在于，它要求用户转动很多头。")]),t._v(" "),a("h2",{attrs:{id:"添加视觉反馈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#添加视觉反馈"}},[t._v("#")]),t._v(" 添加视觉反馈")]),t._v(" "),a("p",[t._v("要向光标添加视觉反馈以显示光标单击或融合的时间，我们可以使用动画组件。当光标与实体相交时，它将发出一个事件，动画系统将使用以下begin属性拾取事件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity\n  animation__click="property: scale; startEvents: click; easing: easeInCubic; dur: 150; from: 0.1 0.1 0.1; to: 1 1 1"\n  animation__fusing="property: scale; startEvents: fusing; easing: easeInCubic; dur: 1500; from: 1 1 1; to: 0.1 0.1 0.1"\n  animation__mouseleave="property: scale; startEvents: mouseleave; easing: easeInCubic; dur: 500; to: 1 1 1"\n  cursor="fuse: true;"\n  material="color: black; shader: flat"\n  position="0 0 -3"\n  geometry="primitive: ring"></a-entity>\n\n')])])]),a("p",[t._v("要播放具有视觉反馈的光标示例，请在CodePen上查看“具有视觉反馈的光标”示例。")])])}),[],!1,null,null,null);e.default=s.exports}}]);