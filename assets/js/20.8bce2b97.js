(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{308:function(t,e,a){"use strict";a.r(e);var r=a(28),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"最佳实践"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践"}},[t._v("#")]),t._v(" 最佳实践")]),t._v(" "),a("h2",{attrs:{id:"a-frame"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-frame"}},[t._v("#")]),t._v(" A-Frame")]),t._v(" "),a("p",[t._v("A-Frame的核心结构是实体构件（ECS）。将应用程序代码放置在纯A-Frame组件中并对其进行结构，以实现可重用性、模块性、可组合性、去耦、封装、声明性和可测试性。")]),t._v(" "),a("p",[t._v("不要这样做：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<a-scene>\n  <a-box></a-box>\n  \x3c!-- ... --\x3e\n</a-scene>\n\n<script>\n  // My JavaScript code here!\n  // ... NO!\n<\/script>\n\n")])])]),a("p",[t._v("将代码放在A-Frame组件中，以便在正确的时间执行它们，封装可重用代码，并使用框架，这是使用A-Frame的目的。\n如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<script>\n  AFRAME.registerComponent('code-that-does-this', {\n    init: function () {\n      // Code here.\n      console.log(this.el);\n    }\n  });\n\n  AFRAME.registerComponent('code-to-attach-to-box', {\n    init: function () {\n      // Code here.\n      console.log(this.el);\n    }\n  });\n<\/script>\n\n<a-scene code-that-does-this>\n  <a-box code-to-attach-to-box></a-box>\n  \x3c!-- ... --\x3e\n</a-scene>\n")])])]),a("h2",{attrs:{id:"webvr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webvr"}},[t._v("#")]),t._v(" WebVR")]),t._v(" "),a("h2",{attrs:{id:"性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能"}},[t._v("#")]),t._v(" 性能")]),t._v(" "),a("p",[t._v("在虚拟现实中，性能至关重要。为了让人们感到舒适，必须保持高帧率。以下是一些有助于提高A帧场景性能的方法：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("使用推荐的硬件规格。")])]),t._v(" "),a("li",[a("p",[t._v("使用stats组件监视各种度量（FPS、顶点和面计数、几何体和材质计数、绘制调用、实体数）。我们希望最大化FPS并最小化其他所有内容。")])]),t._v(" "),a("li",[a("p",[t._v("尽可能限制抽签次数。没有优化的每个几何体、对象、模型通常都是一个绘图调用。经验法则，尽量控制在300以下。[合并][geometrymerger]尽可能将所有静态网格合并在一起。您可以使用[geometry merger][geometrymerger]，然后使用启用顶点颜色的3.js材质。js几何体保留数据，如颜色、每个顶点的uv，这些数据可用于在合并后维护和操作几何体。")])]),t._v(" "),a("li",[a("p",[t._v("利用资产管理系统对资产进行浏览器缓存和预加载。")])]),t._v(" "),a("li",[a("p",[t._v("如果使用模型，请将灯光烘焙到纹理中，而不是依赖于实时照明和阴影。")])]),t._v(" "),a("li",[a("p",[t._v("通常，场景中实体和灯光的数量越少越好。")])]),t._v(" "),a("li",[a("p",[t._v("确保纹理的分辨率大小为2的幂（例如256x256、512x1024），以避免渲染器在运行时必须调整纹理大小。")])]),t._v(" "),a("li",[a("p",[t._v("限制模型上的面和顶点数。")])]),t._v(" "),a("li",[a("p",[t._v("一些进一步的技术包括几何实例、几何合并、细节层次（LOD）。")])]),t._v(" "),a("li",[a("p",[t._v("使用光线投射器或碰撞器时，请选择要针对哪些实体进行光线投射，而不是针对场景中的每个对象进行光线投射。")])]),t._v(" "),a("li",[a("p",[t._v("当添加连续运行的行为时，使用A-Frame组件tick处理程序钩住全局渲染循环。使用诸如AFRAME.utils.throttleTick之类的实用程序来限制运行tick处理程序的次数（如果合适）。")])]),t._v(" "),a("li",[a("p",[t._v("使用背景组件而不是a-sky将纯色定义为场景背景。这样可以防止创建不必要的几何图形。")])]),t._v(" "),a("li",[a("p",[t._v("使用three.js级别（el.object3D.position、el.object3D.rotation、el.object3D.scale、el.object3D.visible）更新position、rotation、scale和visible，以避免.setAttribute上的开销。")])]),t._v(" "),a("li",[a("p",[t._v("如果需要创建、删除和重新创建许多相同类型的实体，请使用池组件预生成和重用实体。这避免了动态创建实体的成本，并减少了垃圾收集。")])]),t._v(" "),a("li",[a("p",[t._v("使用动画组件时，直接设置值的动画，这将跳过.setAttribute并直接设置JS值的动画。例如，将components.material.material.opacity设置为动画，而不是material.opacity。")])])]),t._v(" "),a("h2",{attrs:{id:"gpu纹理预加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gpu纹理预加载"}},[t._v("#")]),t._v(" GPU纹理预加载")]),t._v(" "),a("p",[t._v("在无阻塞纹理上传到GPU可用之前，尝试将所有材质和纹理绘制到前面。首次绘制材质和纹理时，浏览器将在上载到GPU时挂起并阻止。我们可以通过调用以下命令手动预加载纹理：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("document.querySelector('a-scene').renderer.setTexture2D(ourTexture, 0);\n\n")])])]),a("p",[t._v("我们将尝试在a-Frame中提供一个方便的API来自动执行此操作。")]),t._v(" "),a("p",[t._v("例如，这在360°图像库中很明显。如果我们看看浏览器性能工具，第一次切换到新图像时会出现帧下降，但第二次切换回图像时会平滑过渡。")]),t._v(" "),a("p",[t._v("尽量重复使用材料和纹理，以少量独特的材料为目标。纹理图谱提供了一种有效的方法来重复利用材料，同时给人以更多样的印象。简单的three.js材质（如MeshLambertMaterial或MeshBasicMaterial）性能更好，通常足以用于低多边形场景。")]),t._v(" "),a("p",[t._v("特别是，未照明（基本）材质上的预烘焙照明可以显著提高性能。A-Frame的默认基于PBR的（标准）材质在物理上更逼真，但在简单场景中也更昂贵，而且通常是不必要的。")]),t._v(" "),a("h2",{attrs:{id:"在javascript中最小化垃圾收集"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在javascript中最小化垃圾收集"}},[t._v("#")]),t._v(" 在JavaScript中最小化垃圾收集")]),t._v(" "),a("p",[t._v("尽可能避免创建垃圾和实例化新的JavaScript对象、数组、字符串和函数。在2dweb中，创建大量JavaScript对象并没有什么大不了的，因为垃圾收集器有很多空闲时间可以运行。对于VR，垃圾收集可能会导致在暂停清理内存时丢失帧。为了避免这种情况，我们尽量减少内存的分配，并保留对象以防止它们被垃圾收集。")]),t._v(" "),a("p",[t._v("了解有关在Firefox和Chrome性能工具中检测分配和垃圾收集的更多信息。")]),t._v(" "),a("p",[t._v("尽量避免像Object.keys（obj）.forEach（function（）{}）；，这样的模式创建新的数组、函数和回调，而不是使用for（obj中的key）。或者对于数组迭代，避免使用.forEach并改用一个简单的for循环。避免使用utils.extend（target，source）而不是utils.clone或.slice等方法不必要地复制对象。")]),t._v(" "),a("p",[t._v("如果发出事件，请尝试对事件详细信息重用同一对象：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("AFRAME.registerComponent('foo', {\n  init: function () {\n    this.someData = [];\n    this.evtDetail = {someData: this.someData};\n  },\n\n  tick: function (time) {\n    this.someData.push(time);\n    this.el.emit('bar', this.evtDetail);\n  }\n});\n")])])]),a("p",[t._v("上面的所有建议在tick()处理程序中都特别重要，它们将在每一帧上运行。")]),t._v(" "),a("h3",{attrs:{id:"tick处理程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tick处理程序"}},[t._v("#")]),t._v(" tick处理程序")]),t._v(" "),a("p",[t._v("在组件标记处理程序中，要节省创建新对象的时间。尝试重用对象。创建私有可重用辅助变量的模式是带有闭包的。下面我们创建一个辅助向量和四元数，并在帧之间重用它们，而不是在每个帧上创建新的。请注意，这些变量不会保持状态，因为它们将在组件的所有实例之间共享。这样做将减少内存使用和垃圾收集：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("AFRAME.registerComponent('foo', {\n  tick: function () {\n    this.doSomething();\n  },\n\n  doSomething: (function () {\n    var helperVector = new THREE.Vector3();\n    var helperQuaternion = new THREE.Quaternion();\n\n    return function () {\n      helperVector.copy(this.el.object3D.position);\n      helperQuaternion.copy(this.el.object3D.quaternion);\n    };\n  })()\n});\n")])])]),a("p",[t._v("另外，如果我们在tick中不断修改组件，请确保传递相同的对象以更新属性。A-Frame将跟踪最新通过的对象，并在随后的额外提速调用中禁用类型检查。下面是一个建议的tick函数示例，该函数修改每个tick上的旋转：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("AFRAME.registerComponent('foo', {\n  tick: function () {\n    var el = this.el;\n    var rotationTmp = this.rotationTmp = this.rotationTmp || {x: 0, y: 0, z: 0};\n    var rotation = el.getAttribute('rotation');\n    rotationTmp.x = rotation.x + 0.1;\n    rotationTmp.y = rotation.y + 0.1;\n    rotationTmp.z = rotation.z + 0.1;\n    el.setAttribute('rotation', rotationTmp);\n  }\n});\n")])])]),a("p",[t._v("同样，在tick函数中要小心，把它们当作关键性能代码，因为它们将每秒运行90次。考虑使用utils.throttlectick以较少的间隔运行代码。")]),t._v(" "),a("h2",{attrs:{id:"vr-设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vr-设计"}},[t._v("#")]),t._v(" VR 设计")]),t._v(" "),a("p",[t._v("虚拟现实设计不同于平面体验设计。作为一种新的媒介，有一套新的最佳实践可以遵循，特别是为了保持用户的舒适感和存在感。这篇文章写得很透彻，所以我们遵从这些指南。请注意，虚拟现实交互设计是相当新的，没有什么是绝对的：")]),t._v(" "),a("p",[t._v("需要注意的是：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("通常的黄金法则是永远不要意外地从用户手中夺走相机的控制权。")])]),t._v(" "),a("li",[a("p",[t._v("单位（如位置单位）应视为米。这是因为WebVR API返回的姿势是以米为单位的，而米是输入到大多数相机控件中的。以单位为米，达到了预期的规模。")])])]),t._v(" "),a("p",[t._v("使用手和控制器。为了获得最佳体验，请将您的应用程序定向到特定的形状因子，而不是一次为所有平台淡化它。")])])}),[],!1,null,null,null);e.default=n.exports}}]);