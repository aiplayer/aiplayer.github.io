(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{356:function(t,e,a){"use strict";a.r(e);var v=a(28),r=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"材料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#材料"}},[t._v("#")]),t._v(" 材料")]),t._v(" "),a("p",[t._v("材料组件使实体外观。我们可以定义颜色，不透明度或纹理之类的属性。通常将其与提供形状的几何部件配对。")]),t._v(" "),a("p",[t._v("我们可以注册自定义材质以扩展材质成分，以提供广泛的视觉效果。")]),t._v(" "),a("h2",{attrs:{id:"例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#例"}},[t._v("#")]),t._v(" 例")]),t._v(" "),a("p",[t._v("使用默认的标准材质定义红色材质：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity geometry="primitive: box" material="color: red"></a-entity>\n\n')])])]),a("p",[t._v("这是使用其他材料的示例：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity geometry="primitive: box" material="shader: flat; color: red"></a-entity>\n\n')])])]),a("p",[t._v("这是使用示例自定义材料的示例：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity geometry="primitive: plane"\n          material="shader: ocean; color: blue; wave-height: 10">\n</a-entity>\n\n')])])]),a("h2",{attrs:{id:"特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),a("p",[t._v("材料成分具有一些基本属性。根据所应用的材料类型，可以使用更多属性。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("属性")]),t._v(" "),a("th",[t._v("描述")]),t._v(" "),a("th",[t._v("默认值")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("alphaTest")]),t._v(" "),a("td",[t._v("透明度的Alpha测试阈值。")]),t._v(" "),a("td",[t._v("0")])]),t._v(" "),a("tr",[a("td",[t._v("depthTest")]),t._v(" "),a("td",[t._v("渲染材质时是否启用深度测试。")]),t._v(" "),a("td",[t._v("true")])]),t._v(" "),a("tr",[a("td",[t._v("flatShading")]),t._v(" "),a("td",[t._v("使用THREE.FlatShading而不是THREE.StandardShading。")]),t._v(" "),a("td",[t._v("false")])]),t._v(" "),a("tr",[a("td",[t._v("npot")]),t._v(" "),a("td",[t._v("对非二次幂（NPOT）纹理使用设置。")]),t._v(" "),a("td",[t._v("false")])]),t._v(" "),a("tr",[a("td",[t._v("offset")]),t._v(" "),a("td",[t._v("要使用的纹理偏移量。")]),t._v(" "),a("td",[t._v("{x：0，y：0}")])]),t._v(" "),a("tr",[a("td",[t._v("opacity")]),t._v(" "),a("td",[t._v("透明度的程度。如果该transparent属性不是true，则材质将保持不透明，并且opacity只会影响颜色。")]),t._v(" "),a("td",[t._v("1.0")])]),t._v(" "),a("tr",[a("td",[t._v("repeat")]),t._v(" "),a("td",[t._v("重复使用纹理。")]),t._v(" "),a("td",[t._v("{x：1，y：1}")])]),t._v(" "),a("tr",[a("td",[t._v("shader")]),t._v(" "),a("td",[t._v("使用哪种材料。默认为标准材质。可以设置为平面材质或注册的自定义着色器材质。")]),t._v(" "),a("td",[t._v("standard")])]),t._v(" "),a("tr",[a("td",[t._v("side")]),t._v(" "),a("td",[t._v("渲染网格的哪一侧。可以是一个front，back或double。")]),t._v(" "),a("td",[t._v("front")])]),t._v(" "),a("tr",[a("td",[t._v("transparent")]),t._v(" "),a("td",[t._v("材料是否透明。透明实体在非透明实体之后呈现。")]),t._v(" "),a("td",[t._v("false")])]),t._v(" "),a("tr",[a("td",[t._v("vertexColors")]),t._v(" "),a("td",[t._v("是使用顶点颜色还是使用面颜色来着色材质。可以是一个none，vertex或face。")]),t._v(" "),a("td",[t._v("none")])]),t._v(" "),a("tr",[a("td",[t._v("visible")]),t._v(" "),a("td",[t._v("材料是否可见。射线广播公司将忽略看不见的材料。")]),t._v(" "),a("td",[t._v("true")])]),t._v(" "),a("tr",[a("td",[t._v("blending")]),t._v(" "),a("td",[t._v("材质的RGB和Alpha的混合模式已发送到WebGLRenderer。可以是一个none，normal，additive，subtractive或multiply。")]),t._v(" "),a("td",[t._v("normal")])]),t._v(" "),a("tr",[a("td",[t._v("dithering")]),t._v(" "),a("td",[t._v("材料是否因噪音而抖动。消除渐变产生的条纹，例如照明产生的条纹。")]),t._v(" "),a("td",[t._v("true")])])])]),t._v(" "),a("h2",{attrs:{id:"事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件"}},[t._v("#")]),t._v(" 事件")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("活动名称")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("materialtextureloaded")]),t._v(" "),a("td",[t._v("将纹理加载到材质上。")])]),t._v(" "),a("tr",[a("td",[t._v("materialvideoloadeddata")]),t._v(" "),a("td",[t._v("视频数据已加载，即将播放。")])]),t._v(" "),a("tr",[a("td",[t._v("materialvideoended")]),t._v(" "),a("td",[t._v("对于视频纹理，在视频结束时发出（可能不适用于loop）。")])])])]),t._v(" "),a("h2",{attrs:{id:"内置材料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内置材料"}},[t._v("#")]),t._v(" 内置材料")]),t._v(" "),a("p",[t._v("A-Frame附带了几种内置材料。")]),t._v(" "),a("h3",{attrs:{id:"standard"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#standard"}},[t._v("#")]),t._v(" standard")]),t._v(" "),a("p",[t._v("该standard材质是默认材质。它使用基于物理的 THREE.MeshStandardMaterial。")]),t._v(" "),a("h4",{attrs:{id:"特性-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性-2"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),a("p",[t._v("这些属性位于基础材料属性之上。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("属性")]),t._v(" "),a("th",[t._v("描述")]),t._v(" "),a("th",[t._v("默认值")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("environmentalOcclusionMap")]),t._v(" "),a("td",[t._v("环境光遮挡图。用于向网格添加阴影。可以是"),a("img"),t._v("或内联URL 的选择器。需要第二组UV（请参阅下文）。")]),t._v(" "),a("td",[t._v("none")])]),t._v(" "),a("tr",[a("td",[t._v("environmentOcclusionMapIntensity")]),t._v(" "),a("td",[t._v("环境光遮挡贴图的强度，介于0和1之间的数字。")]),t._v(" "),a("td",[t._v("1")])]),t._v(" "),a("tr",[a("td",[t._v("环境遮挡纹理重复")]),t._v(" "),a("td",[t._v("环境光遮挡纹理在X和Y方向上重复多少次。")]),t._v(" "),a("td",[t._v("1 1")])]),t._v(" "),a("tr",[a("td",[t._v("environmentalOcclusionTextureOffset")]),t._v(" "),a("td",[t._v("环境光遮挡纹理如何在xy方向上偏移。")]),t._v(" "),a("td",[t._v("0 0")])]),t._v(" "),a("tr",[a("td",[t._v("颜色")]),t._v(" "),a("td",[t._v("基本漫反射颜色。")]),t._v(" "),a("td",[t._v("#fff")])]),t._v(" "),a("tr",[a("td",[t._v("置换图\t位移图。")]),t._v(" "),a("td",[t._v("用于扭曲网格。可以是"),a("img"),t._v("或内联URL 的选择器。")]),t._v(" "),a("td",[t._v("none")])]),t._v(" "),a("tr",[a("td",[t._v("位移比例")]),t._v(" "),a("td",[t._v("位移图效果的强度")]),t._v(" "),a("td",[t._v("1")])]),t._v(" "),a("tr",[a("td",[t._v("排量偏差")]),t._v(" "),a("td",[t._v("位移图的零点。")]),t._v(" "),a("td",[t._v("0.5")])]),t._v(" "),a("tr",[a("td",[t._v("置换纹理重复")]),t._v(" "),a("td",[t._v("位移纹理在X和Y方向上重复多少次。")]),t._v(" "),a("td",[t._v("1 1")])]),t._v(" "),a("tr",[a("td",[t._v("migrationTextureOffset")]),t._v(" "),a("td",[t._v("位移纹理如何在xy方向上偏移。")]),t._v(" "),a("td",[t._v("0 0")])]),t._v(" "),a("tr",[a("td",[t._v("发射的")]),t._v(" "),a("td",[t._v("发光照明组件的颜色。用于使物体产生光，即使场景中没有其他照明。")]),t._v(" "),a("td",[t._v("＃000")])]),t._v(" "),a("tr",[a("td",[t._v("发射强度")]),t._v(" "),a("td",[t._v("发光照明组件的强度。")]),t._v(" "),a("td",[t._v("1个")])]),t._v(" "),a("tr",[a("td",[t._v("高度")]),t._v(" "),a("td",[t._v("视频的高度（以像素为单位）（如果定义了视频纹理）。")]),t._v(" "),a("td",[t._v("360")])]),t._v(" "),a("tr",[a("td",[t._v("envMap")]),t._v(" "),a("td",[t._v("反射的环境多维数据集纹理。可以选择 或以逗号分隔的网址列表。")]),t._v(" "),a("td",[t._v("none")])]),t._v(" "),a("tr",[a("td",[t._v("多雾路段")]),t._v(" "),a("td",[t._v("物料是否受雾影响。")]),t._v(" "),a("td",[t._v("真正")])]),t._v(" "),a("tr",[a("td",[t._v("金属性")]),t._v(" "),a("td",[t._v("材料从0到金属有多金属1。")]),t._v(" "),a("td",[t._v("0")])]),t._v(" "),a("tr",[a("td",[t._v("法线贴图")]),t._v(" "),a("td",[t._v("法线贴图。用于添加复杂细节的错觉。可以是"),a("img"),t._v("或内联URL 的选择器。")]),t._v(" "),a("td",[t._v("none")])]),t._v(" "),a("tr",[a("td",[t._v("normalScale")]),t._v(" "),a("td",[t._v("法线贴图在X和Y方向上的效果比例。")]),t._v(" "),a("td",[t._v("1 1")])]),t._v(" "),a("tr",[a("td",[t._v("normalTextureRepeat")]),t._v(" "),a("td",[t._v("正常纹理在X和Y方向上重复多少次。")]),t._v(" "),a("td",[t._v("1 1")])]),t._v(" "),a("tr",[a("td",[t._v("normalTextureOffset")]),t._v(" "),a("td",[t._v("普通纹理如何在xy方向上偏移。")]),t._v(" "),a("td",[t._v("0 0")])]),t._v(" "),a("tr",[a("td",[t._v("重复")]),t._v(" "),a("td",[t._v("纹理（由定义src）在X和Y方向上重复多少次。")]),t._v(" "),a("td",[t._v("1 1")])]),t._v(" "),a("tr",[a("td",[t._v("粗糙度")]),t._v(" "),a("td",[t._v("物料从0到到底有多粗糙1。较粗糙的材料会比光滑的材料向更多的方向散射反射光。")]),t._v(" "),a("td",[t._v("0.5")])]),t._v(" "),a("tr",[a("td",[t._v("sphereEnvMap")]),t._v(" "),a("td",[t._v("环境球形纹理的反射。可以是"),a("img"),t._v("或内联URL 的选择器。")]),t._v(" "),a("td",[t._v("none")])]),t._v(" "),a("tr",[a("td",[t._v("宽度")]),t._v(" "),a("td",[t._v("视频宽度（以像素为单位）（如果定义了视频纹理）。")]),t._v(" "),a("td",[t._v("640")])]),t._v(" "),a("tr",[a("td",[t._v("线框")]),t._v(" "),a("td",[t._v("是否仅渲染几何图形边缘。")]),t._v(" "),a("td",[t._v("false")])]),t._v(" "),a("tr",[a("td",[t._v("wireframeLinewidth")]),t._v(" "),a("td",[t._v("渲染线的宽度（以px为单位）。")]),t._v(" "),a("td",[t._v("2")])]),t._v(" "),a("tr",[a("td",[t._v("src")]),t._v(" "),a("td",[t._v("图像或视频纹理贴图。可以是"),a("img"),t._v("或"),a("video",[t._v("或内联URL 的选择器。")])]),t._v(" "),a("td",[t._v("none")])])])]),t._v(" "),a("h2",{attrs:{id:"基于物理的阴影"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于物理的阴影"}},[t._v("#")]),t._v(" 基于物理的阴影")]),t._v(" "),a("p",[t._v("基于物理的阴影是一种阴影模型，旨在使材料对照明条件具有逼真的表现。外观是入射光与材料特性之间相互作用的结果。")]),t._v(" "),a("p",[t._v("为了达到逼真，漫color，metalness，roughness材料的性能必须精确控制，往往是基于现实世界的材料研究。有些人已经为各种材料编制了现实价值图表，我们可以以此为起点。")]),t._v(" "),a("p",[t._v("例如，对于树皮材料，我们可以设置：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity geometry="primitive: cylinder"\n          material="src: treebark.png; color: #696969; roughness: 1; metalness: 0">\n</a-entity>\n\n')])])]),a("h2",{attrs:{id:"失真贴图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#失真贴图"}},[t._v("#")]),t._v(" 失真贴图")]),t._v(" "),a("p",[t._v("有以下三个属性可以使人产生复杂几何图形的错觉：")]),t._v(" "),a("p",[t._v("环境光遮挡贴图 -在环境光较少的区域应用微妙的阴影。直接（点，定向）光不会影响环境光遮挡图。烘焙的环境光遮挡需要第二组UV，可以在建模软件中或使用JavaScript将其添加到网格中。\n置换贴图 -以高分辨率变形更简单的模型，从而提供更多细节。这将影响网格的轮廓，但可能会很昂贵。\n法线贴图 -定义该点处的曲面角度。呈现复杂几何图形的外观而不会扭曲模型。这不会改变几何形状，但法线贴图便宜。\n环境图\n在envMap和sphericalEnvMap属性定义的材料反映了什么样的环境。环境反射的清晰度取决于metalness和roughness属性。")]),t._v(" "),a("p",[t._v("该sphericalEnvMap属性采用单个球面贴图纹理。您将分配给的那种"),a("a-sky",[t._v("。")])],1),t._v(" "),a("p",[t._v("与纹理不同，该envMap属性采用一个立方体贴图，将六个图像放在一起形成一个立方体。立方体贴图环绕网格并作为纹理应用。")]),t._v(" "),a("p",[t._v("例如：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-scene>\n  <a-assets>\n    <a-cubemap id="sky">\n      <img src="right.png">\n      <img src="left.png">\n      <img src="top.png">\n      <img src="bottom.png">\n      <img src="front.png">\n      <img src="back.png">\n    </a-cubemap>\n  </a-assets>\n\n  <a-entity geometry="primitive: box" material="envMap: #sky; roughness: 0"></a-entity>\n</a-scene>\n')])])]),a("h2",{attrs:{id:"flat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flat"}},[t._v("#")]),t._v(" flat")]),t._v(" "),a("p",[t._v("该flat材质使用THREE.MeshBasicMaterial。平面材料不受场景照明条件的影响。这对于诸如图像或视频之类的东西很有用。设置shader为flat：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity geometry="primitive: plane" material="shader: flat; src: #cat-image"></a-entity>\n\n\n')])])]),a("h3",{attrs:{id:"特性-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性-3"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("属性")]),t._v(" "),a("th",[t._v("描述")]),t._v(" "),a("th",[t._v("默认值")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("color")]),t._v(" "),a("td",[t._v("基本漫反射颜色。\t#fff")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("fog")]),t._v(" "),a("td",[t._v("物料是否受雾影响。")]),t._v(" "),a("td",[t._v("true")])]),t._v(" "),a("tr",[a("td",[t._v("height")]),t._v(" "),a("td",[t._v("视频的高度（以像素为单位）（如果定义了视频纹理）。")]),t._v(" "),a("td",[t._v("360")])]),t._v(" "),a("tr",[a("td",[t._v("repeat")]),t._v(" "),a("td",[t._v("纹理（由定义src）在X和Y方向上重复多少次。")]),t._v(" "),a("td",[t._v("1 1")])]),t._v(" "),a("tr",[a("td",[t._v("src")]),t._v(" "),a("td",[t._v("图像或视频纹理贴图。可以是"),a("img"),t._v("或"),a("video",[t._v("或内联URL 的选择器。")])]),t._v(" "),a("td",[t._v("none")])]),t._v(" "),a("tr",[a("td",[t._v("width")]),t._v(" "),a("td",[t._v("视频宽度（以像素为单位）（如果定义了视频纹理）。")]),t._v(" "),a("td",[t._v("640")])]),t._v(" "),a("tr",[a("td",[t._v("wireframe")]),t._v(" "),a("td",[t._v("是否仅渲染几何图形边缘。")]),t._v(" "),a("td",[t._v("false")])]),t._v(" "),a("tr",[a("td",[t._v("wireframeLinewidth")]),t._v(" "),a("td",[t._v("渲染线的宽度（以px为单位）。")]),t._v(" "),a("td",[t._v("2")])])])]),t._v(" "),a("h3",{attrs:{id:"贴图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#贴图"}},[t._v("#")]),t._v(" 贴图")]),t._v(" "),a("p",[t._v("要使用内置材料之一设置纹理，请指定src 属性。src可以是资产管理系统中"),a("img"),t._v("或"),a("video",[t._v("元素 的选择器：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-scene>\n  <a-assets>\n    <img id="my-texture" src="texture.png">\n  </a-assets>\n\n  <a-entity geometry="primitive: box" material="src: #my-texture"></a-entity>\n</a-scene>\n')])])]),a("p",[t._v("src也可以是内联URL。请注意，我们不会通过此方法来缓存浏览器或进行预加载。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-scene>\n  <a-entity geometry="primitive: box" material="src: url(texture.png)"></a-entity>\n</a-scene>\n\n')])])]),a("p",[t._v("其他大多数属性都可以与纹理一起使用。例如，该 color属性将用作基本颜色，并且每个像素与纹理相乘。进行设置#fff以保持纹理的原始颜色。")]),t._v(" "),a("p",[t._v("A-Frame缓存纹理，以免将多余的纹理推送到GPU。")]),t._v(" "),a("h2",{attrs:{id:"影片纹理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#影片纹理"}},[t._v("#")]),t._v(" 影片纹理")]),t._v(" "),a("p",[t._v("视频纹理是循环播放还是自动播放取决于用于创建纹理的视频元素。如果我们只是传递一个URL而不是创建和传递视频元素，则默认情况下纹理将循环播放并自动播放。要另外指定，请在资产管理系统中创建一个video元素，然后传递该id属性的选择器（例如#my-video）：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-scene>\n  <a-assets>\n    \x3c!-- No loop. --\x3e\n    <video id="my-video" src="video.mp4" autoplay="true">\n  </a-assets>\n\n  <a-entity geometry="primitive: box" material="src: #my-video"></a-entity>\n</a-scene>\n\n')])])]),a("h2",{attrs:{id:"控制视频纹理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#控制视频纹理"}},[t._v("#")]),t._v(" 控制视频纹理")]),t._v(" "),a("p",[t._v("要控制视频播放（例如暂停或搜索），我们可以使用video元素控制媒体播放。例如：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var videoEl = document.querySelector('#my-video');\nvideoEl.currentTime = 122;  // Seek to 122 seconds.\nvideoEl.pause();\n\n")])])]),a("p",[t._v("如果您要传递内嵌网址，则效果会不佳，在这种情况下，A-Frame会在内部创建视频元素。要获得video元素的句柄，我们应该在中定义一个"),a("a-assets",[t._v("。")])],1),t._v(" "),a("h2",{attrs:{id:"画布纹理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#画布纹理"}},[t._v("#")]),t._v(" 画布纹理")]),t._v(" "),a("p",[t._v("我们可以使用a "),a("canvas",[t._v("作为纹理源。随着画布的变化，纹理将自动刷新。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<script>\n  AFRAME.registerComponent(\'draw-canvas\', {\n    schema: {default: \'\'},\n\n    init: function () {\n      this.canvas = document.getElementById(this.data);\n      this.ctx = this.canvas.getContext(\'2d\');\n\n      // Draw on canvas...\n    }\n  });\n<\/script>\n\n<a-assets>\n  <canvas id="my-canvas" crossorigin="anonymous"></canvas>\n</a-assets>\n\n<a-entity geometry="primitive: plane" material="src: #my-canvas"\n          draw-canvas="my-canvas"></a-entity>\n\n')])])]),a("h2",{attrs:{id:"重复纹理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重复纹理"}},[t._v("#")]),t._v(" 重复纹理")]),t._v(" "),a("p",[t._v("我们可能要重复拼贴纹理而不是拉伸它们。该repeat 属性可以重复纹理。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity geometry="primitive: plane; width: 100"\n          material="src: carpet.png; repeat: 100 20">\n</a-entity>\n\n')])])]),a("h2",{attrs:{id:"透明度问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#透明度问题"}},[t._v("#")]),t._v(" 透明度问题")]),t._v(" "),a("p",[t._v("透明度和Alpha通道在3D图形中非常棘手。如果您遇到前景中的透明材质无法在背景中的材质上正确合成的问题，则该问题可能是由于OpenGL合成器（WebGL是其API）的基础设计所致。")]),t._v(" "),a("p",[t._v("在理想情况下，无论开发人员将实体放置在3D空间中的位置还是在标记中定义元素的顺序，A-Frame中的透明度都将“起作用”。我们经常会遇到前景实体遮挡背景实体的场景。这会造成混乱和不必要的视觉缺陷。")]),t._v(" "),a("p",[t._v("要变通解决此问题，请尝试更改HTML中实体的顺序。")]),t._v(" "),a("p",[t._v("当使用PNG图像作为切口或遮罩（图像的一部分应完全透明，其余部分完全不透明）时，请尝试进行设置transparent: false 并喜欢alphaTest: 0.5解决透明度问题。试一下alpha测试值。")]),t._v(" "),a("h2",{attrs:{id:"render-order-组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render-order-组件"}},[t._v("#")]),t._v(" render-order 组件")]),t._v(" "),a("p",[t._v("使用render-order组件告诉渲染器按深度对透明对象进行排序，并能够通过命名图层手动定义HTML中实体的渲染顺序。如果您有透明度订购问题，请使用此组件。")]),t._v(" "),a("p",[t._v("注册自定义着色器材质\n我们可以使用来注册自定义着色器材质的外观和效果 AFRAME.registerShader。")]),t._v(" "),a("p",[t._v("让我们来看一个带有逐步注释的CodePen示例。与往常一样，我们需要包括A-Frame脚本。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<script src="https://aframe.io/releases/1.0.4/aframe.min.js"><\/script>\n\n')])])]),a("p",[t._v("接下来，我们在A-Frame脚本之后但在场景声明之前定义所需的所有组件和着色器。在这里，我们开始my-custom着色器。模式为着色器声明任何参数。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<script>\nAFRAME.registerShader('my-custom', {\n  schema: {\n    // ...\n  }\n});\n<\/script>\n\n\n")])])]),a("p",[t._v("我们通常希望支持color和opacity属性。is: 'uniform'告诉A-Frame此属性应在着色器中显示为统一值：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<script>\nAFRAME.registerShader('my-custom', {\n  schema: {\n    color: {type: 'color', is: 'uniform', default: 'red'},\n    opacity: {type: 'number', is: 'uniform', default: 1.0}\n  }\n});\n<\/script>\n\n")])])]),a("p",[t._v("设置raw为true使用THREE.RawShaderMaterial而不是 ShaderMaterial，因此内置的制服和属性不会自动添加到您的着色器代码中。在这里，我们希望包括带有GLSL常量等的常用前缀，因此保留它false。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("raw: false,\n\n")])])]),a("p",[t._v("我们将通过省略使用默认的顶点着色器vertexShader。请注意，如果我们的片段着色器关心纹理坐标，则我们的顶点着色器应设置varying要在片段着色器中使用的值。")]),t._v(" "),a("p",[t._v("由于几乎所有支持WebVR的浏览器都支持ES6，因此我们将片段着色器定义为多行字符串：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  fragmentShader:\n`\n  // Use medium precision.\n  precision mediump float;\n\n  // This receives the color value from the schema, which becomes a vec3 in the shader.\n  uniform vec3 color;\n\n  // This receives the opacity value from the schema, which becomes a number.\n  uniform float opacity;\n\n  // This is the shader program.\n  // A fragment shader can set the color via gl_FragColor,\n  // or decline to draw anything via discard.\n  void main () {\n    // Note that this shader doesn't use texture coordinates.\n    // Set the RGB portion to our color,\n    // and the alpha portion to our opacity.\n    gl_FragColor = vec4(color, opacity);\n  }\n`\n});\n<\/script>\n\n")])])]),a("p",[t._v("并使用来自material组件的着色器：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('\x3c!-- A box using our shader, not fully opaque and blue. --\x3e\n<a-box material="shader: my-custom; color: blue; opacity: 0.7; transparent: true" position="0 0 -2"></a-box>\n\n')])])]),a("h2",{attrs:{id:"registershader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#registershader"}},[t._v("#")]),t._v(" registerShader")]),t._v(" "),a("p",[t._v("与组件一样，自定义材料也具有架构和生命周期处理程序。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("属性")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("fragmentShader\t包含片段着色器的可选字符串。如果省略，则使用简单的默认值。")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("init\t着色器初始化期间调用一次的可选生命周期处理程序。用于创建材料。")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("raw")]),t._v(" "),a("td",[t._v("可选的。如果为true，则使用THREE.RawShaderMaterial逐字接受着色器。如果为false（默认），则使用THREE.ShaderMaterial。")])]),t._v(" "),a("tr",[a("td",[t._v("schema")]),t._v(" "),a("td",[t._v("定义着色器将用来扩展材质组件的属性，统一，属性。")])]),t._v(" "),a("tr",[a("td",[t._v("update")]),t._v(" "),a("td",[t._v("着色器初始化期间和数据更新时调用一次的可选生命周期处理程序。用于更新材质或着色器。")])]),t._v(" "),a("tr",[a("td",[t._v("vertexShader")]),t._v(" "),a("td",[t._v("包含顶点着色器的可选字符串。如果省略，则使用简单的默认值。")])])])]),t._v(" "),a("h2",{attrs:{id:"架构图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构图"}},[t._v("#")]),t._v(" 架构图")]),t._v(" "),a("p",[t._v("我们可以定义材料属性，就像定义组件属性一样。数据将用作我们用于创建材料的数据：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("AFRAME.registerShader('custom', {\n  schema: {\n    emissive: {default: '#000'},\n    wireframe: {default: false}\n  }\n});\n")])])]),a("p",[t._v("要将数据值作为统一值传递到着色器，请is: 'uniform'在定义中包括：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("AFRAME.registerShader('my-custom', {\n  schema: {\n    color: {type:'color', is:'uniform', default:'red'},\n    opacity: {type:'number', is:'uniform', default:1.0}\n  },\n  ...\n")])])]),a("p",[t._v("支持的统一类型\n下表总结了A-Frame支持的制服类型。注意，在许多情况下，time可以消除对tick()处理程序的需求。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("A-Frame")]),t._v(" "),a("th",[t._v("三种类型")]),t._v(" "),a("th",[t._v("GLSL着色器类型")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("array")]),t._v(" "),a("td",[t._v("v3")]),t._v(" "),a("td",[t._v("vec3")])]),t._v(" "),a("tr",[a("td",[t._v("color")]),t._v(" "),a("td",[t._v("v3")]),t._v(" "),a("td",[t._v("vec3")])]),t._v(" "),a("tr",[a("td",[t._v("int")]),t._v(" "),a("td",[t._v("i")]),t._v(" "),a("td",[t._v("int")])]),t._v(" "),a("tr",[a("td",[t._v("number")]),t._v(" "),a("td",[t._v("f")]),t._v(" "),a("td",[t._v("float")])]),t._v(" "),a("tr",[a("td",[t._v("map")]),t._v(" "),a("td",[t._v("Ť")]),t._v(" "),a("td",[t._v("map")])]),t._v(" "),a("tr",[a("td",[t._v("time")]),t._v(" "),a("td",[t._v("F")]),t._v(" "),a("td",[t._v("浮点数（毫秒）")])]),t._v(" "),a("tr",[a("td",[t._v("vec2")]),t._v(" "),a("td",[t._v("v2")]),t._v(" "),a("td",[t._v("vec2")])]),t._v(" "),a("tr",[a("td",[t._v("vec3")]),t._v(" "),a("td",[t._v("v3")]),t._v(" "),a("td",[t._v("vec3")])]),t._v(" "),a("tr",[a("td",[t._v("vec4")]),t._v(" "),a("td",[t._v("v4")]),t._v(" "),a("td",[t._v("vec4")])])])]),t._v(" "),a("h2",{attrs:{id:"示例-glsl和着色器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#示例-glsl和着色器"}},[t._v("#")]),t._v(" 示例-GLSL和着色器")]),t._v(" "),a("p",[t._v("为了获得更多定制的视觉效果，我们可以编写GLSL着色器并将其应用于A-Frame实体。")]),t._v(" "),a("p",[t._v("注意：GLSL是用于编写着色器的语法，乍一看可能有点吓人。对于柔和（免费！）的介绍，我们建议使用“着色书”。")]),t._v(" "),a("p",[t._v("这是我们将使用的顶点和片段着色器：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// fragment.glsl\n\nvarying vec2 vUv;\nuniform vec3 color;\nuniform float timeMsec; // A-Frame time in milliseconds.\n\nvoid main() {\n  float time = timeMsec / 1000.0; // Convert from A-Frame milliseconds to typical time in seconds.\n  // Use sin(time), which curves between 0 and 1 over time,\n  // to determine the mix of two colors:\n  //    (a) Dynamic color where 'R' and 'B' channels come\n  //        from a modulus of the UV coordinates.\n  //    (b) Base color.\n  //\n  // The color itself is a vec4 containing RGBA values 0-1.\n  gl_FragColor = mix(\n    vec4(mod(vUv , 0.05) * 20.0, 1.0, 1.0),\n    vec4(color, 1.0),\n    sin(time)\n  );\n}\n")])])]),a("p",[t._v("要使用这些顶点和片段着色器，将它们读入字符串 vertexShader和之后fragmentShader，我们向A-Frame注册我们的自定义着色器：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// shader-grid-glitch.js\n\nAFRAME.registerShader('grid-glitch', {\n  schema: {\n    color: {type: 'color', is: 'uniform'},\n    timeMsec: {type: 'time', is: 'uniform'}\n  },\n\n  vertexShader: vertexShader,\n  fragmentShader: fragmentShader\n});\n")])])]),a("p",[t._v("并使用HTML标记：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-sphere material="shader:grid-glitch; color: blue;" radius="0.5" position="0 1.5 -2"></a-sphere>\n\n')])])]),a("h2",{attrs:{id:"一起使用自定义着色器和组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一起使用自定义着色器和组件"}},[t._v("#")]),t._v(" 一起使用自定义着色器和组件")]),t._v(" "),a("p",[t._v("让我们以上面的实时顶点位移着色器为例，并添加基于相机位置应用偏移的功能。我们将offset声明为统一的vec3值myOffset：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("AFRAME.registerShader（'displacement-offset'，{ \n  schema：{ \n    timeMsec：{ type：'time'，is：'uniform' }，\n    myOffset：{ type：'vec3'，is：'uniform' } \n  }，\n  vertexShader：vertexShader ，\n  fragmentShader：fragmentShader \n}）；\n")])])]),a("p",[t._v("通过使用这个顶点着色器。那么，如何myOffset将其更新 为A帧中的相机位置，以使顶点着色器正确运行？在A-Frame中执行此操作的典型方法是创建具有所需功能的组件，并将其附加到适当的实体。")]),t._v(" "),a("p",[t._v("请注意，shader属性是通过material组件公开的，因此我们使用的形式修改了单个感兴趣的属性setAttribute()。作为避免由于性能原因而造成垃圾的最佳做法：")]),t._v(" "),a("ul",[a("li",[t._v("不要使用将setAttribute对象作为第二个参数的形式。")]),t._v(" "),a("li",[t._v("创建一个组件属性以保存偏移量，以避免创建新的THREE.Vector3每个刻度。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("AFRAME.registerComponent('myoffset-updater', {\n  init: function () {\n    this.offset = new THREE.Vector3();\n  },\n\n  tick: function (t, dt) {\n    this.offset.copy(this.el.sceneEl.camera.el.getAttribute('position'));\n    this.offset.y = 0;\n    this.el.setAttribute('material', 'myOffset', this.offset);\n  }\n});\n\n")])])]),a("p",[t._v("然后，我们使用自定义着色器将组件应用于实体：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-scene>\n  <a-sphere\n    animation="property: scale; dir: alternate; dur: 5000; loop: true; to: 4 4 4"\n    geometry="radius: 0.2"\n    material="shader: displacement-offset"\n    myoffset-updater\n    position="0 1.5 -2">\n  </a-sphere>\n  <a-box color="#CCC" width="3" depth="3" height="0.1" position="0 0 -2"></a-box>\n</a-scene>\n\n')])])]),a("p",[t._v("使用组件设置着色器值的另一个很好的例子是A-Frame Shaders示例。该组件通过计算要在天空着色器中使用的向量来对rotation具有id的元素的更新做出反应：orbitsunPosition")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("AFRAME.registerComponent('sun-position-setter', {\n  init: function () {\n    var skyEl = this.el;\n    var orbitEl = this.el.sceneEl.querySelector('#orbit');\n\n    orbitEl.addEventListener('componentchanged', function changeSun (evt) {\n      var sunPosition;\n      var phi;\n      var theta;\n\n      if (evt.detail.name !== 'rotation') { return; }\n\n      sunPosition = orbitEl.getAttribute('rotation');\n\n      if(sunPosition === null) { return; }\n\n      theta = Math.PI * (- 0.5);\n      phi = 2 * Math.PI * (sunPosition.y / 360 - 0.5);\n      skyEl.setAttribute('material', 'sunPosition', {\n        x: Math.cos(phi),\n        y: Math.sin(phi) * Math.sin(theta),\n        z: -1\n      });\n    });\n  }\n});\n")])])]),a("p",[t._v("此外，还有一些由A-Frame开发人员社区开发的组件，这些组件允许使用存储库中的现有着色器，例如 ShaderToy和ShaderFrog。")]),t._v(" "),a("p",[t._v("但是请注意，这些着色器在计算和图形功能方面可能要求很高，并且某些更复杂的着色器在性能较低的设备（如智能手机）上可能无法正常工作。")]),t._v(" "),a("h2",{attrs:{id:"从组件创建材料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从组件创建材料"}},[t._v("#")]),t._v(" 从组件创建材料")]),t._v(" "),a("p",[t._v("对于registerShaderAPI缺少所需功能（例如，没有tick处理程序，缺少某些统一类型的情况）的情况，我们建议通过在组件内创建Three.js材质（例如RawShaderMaterial， ShaderMaterial）来创建自定义材质：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("AFRAME.registerComponent('custom-material', {\n  schema: {\n    // Add properties.\n  },\n\n  init: function () {\n    this.material = this.el.getOrCreateObject3D('mesh').material = new THREE.ShaderMaterial({\n      // ...\n    });\n  },\n\n  update: function () {\n    // Update `this.material`.\n  }\n});\n    \n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);