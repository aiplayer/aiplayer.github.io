(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{315:function(e,t,a){"use strict";a.r(t);var r=a(28),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"基于标记"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于标记"}},[e._v("#")]),e._v(" 基于标记")]),e._v(" "),a("p",[e._v("标记可以是三种不同的类型：")]),e._v(" "),a("ul",[a("li",[e._v("弘")]),e._v(" "),a("li",[e._v("条码")]),e._v(" "),a("li",[e._v("图案。")])]),e._v(" "),a("p",[e._v("要了解有关标记的更多信息，请阅读以下文章：")]),e._v(" "),a("p",[e._v("AR.js基本的基于标记的教程和标记说明\n仅使用QRCode（QRCodes内的标记）提供AR.js体验。\nTL：DR")]),e._v(" "),a("p",[e._v("Hiro Marker是默认值，实际上不是很有用\n条形码标记是根据矩阵计算自动生成的标记。在上述文章中了解有关如何使用它们的更多信息。如果您需要条形码标记的完整列表，请在此处\n模式标记是自定义标记，从图像（非常简单，高对比度）开始创建，并由用户加载。\n⚡️您可以使用此工具创建模式标记。它将生成要扫描的图像和.patt要加载到AR.js Web应用程序上的文件，以便在运行时识别标记。")]),e._v(" "),a("p",[e._v("如何为图案标记选择好的图像\n标记具有黑色边框和高对比度形状。最近，我们还添加了带有黑色背景的白色边框标记，尽管带有黑色边框的经典边框的表现更好。")]),e._v(" "),a("p",[e._v("这是一篇文章，介绍了有关如何选择用于生成自定义标记的优质图像的所有良好做法：增强AR.js应用程序的10条技巧。")]),e._v(" "),a("h2",{attrs:{id:"基于标记的api参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于标记的api参考"}},[e._v("#")]),e._v(" 基于标记的API参考")]),e._v(" "),a("h3",{attrs:{id:"a-frame"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-frame"}},[e._v("#")]),e._v(" a-frame")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<a-marker/>\n")])])]),a("p",[e._v("这是该实体的属性")]),e._v(" "),a("p",[e._v("|属性\t   |描述\t                                         |组件映射        |\n|type    |标记的类型-['pattern'，'barcode'，'unknown']\t|artoolkitmarker.type|\n|size\t|标记的大小（以米为单位）\t|artoolkitmarker.size|\n|url\t|模式的网址-IIF type ='pattern'\t|artoolkitmarker.patternUrl|\n|value\t|条码的值-IIF type ='barcode'\t|artoolkitmarker.barcodeValue|\n|preset\t|预设参数-['hiro'，'kanji']\t|artoolkitmarker.preset|\n|emitevents |发出'markerFound'和'markerLost'事件-['true'，'false']\t|--|\n|smooth\t|打开/关闭相机平滑功能-['true'，'false']-默认值：false\t|--|\n|smoothCount\t|要平滑跟踪的矩阵数，更多=平滑但慢速跟踪-默认值：5\t|--|\n|smoothTolerance\t|平滑的距离公差，如果矩阵的smoothThreshold＃低于公差，跟踪将保持静止-默认值：0.01\t|--|\n|smoothThreshold\t|平滑阈值，除非足够的矩阵超出公差，否则它将保持不变-默认值：2\t|--|")]),e._v(" "),a("h3",{attrs:{id:"three-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#three-js"}},[e._v("#")]),e._v(" three.js")]),e._v(" "),a("h4",{attrs:{id:"threex-artoolkit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#threex-artoolkit"}},[e._v("#")]),e._v(" threex-artoolkit")]),e._v(" "),a("p",[e._v("threex.artoolkit是three.js扩展，可轻松处理artoolkit。")]),e._v(" "),a("h4",{attrs:{id:"架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构"}},[e._v("#")]),e._v(" 架构")]),e._v(" "),a("p",[e._v("threex.artoolkit由3个类组成")]),e._v(" "),a("p",[e._v("THREEx.ArToolkitSource：被分析以进行位置跟踪的图像。它可以是网络摄像头，视频甚至图像\nTHREEx.ArToolkitContext：这是主要引擎。它实际上会在图像源中找到标记位置。\nTHREEx.ArMarkerControls：它控制标记的位置。它使用经典的three.js控件API。它将确保将内容正确放置在标记的顶部。\nTHREEx.ArMarkerControls")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var parameters = {\n  // size of the marker in meter\n  size: 1,\n  // type of marker - ['pattern', 'barcode', 'unknown' ]\n  type: \"unknown\",\n  // url of the pattern - IIF type='pattern'\n  patternUrl: null,\n  // value of the barcode - IIF type='barcode'\n  barcodeValue: null,\n  // change matrix mode - [modelViewMatrix, cameraTransformMatrix]\n  changeMatrixMode: \"modelViewMatrix\",\n  // turn on/off camera smoothing\n  smooth: true,\n  // number of matrices to smooth tracking over, more = smoother but slower follow\n  smoothCount: 5,\n  // distance tolerance for smoothing, if smoothThreshold # of matrices are under tolerance, tracking will stay still\n  smoothTolerance: 0.01,\n  // threshold for smoothing, will keep still unless enough matrices are over tolerance\n  smoothThreshold: 2\n};\n")])])]),a("p",[e._v("THREEx.ArToolkitContext")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var parameters = {\n    // debug - true if one should display artoolkit debug canvas, false otherwise\n    debug: false,\n    // the mode of detection - ['color', 'color_and_matrix', 'mono', 'mono_and_matrix']\n    detectionMode: 'color_and_matrix',\n    // type of matrix code - valid iif detectionMode end with 'matrix' - [3x3, 3x3_HAMMING63, 3x3_PARITY65, 4x4, 4x4_BCH_13_9_3, 4x4_BCH_13_5_5]\n    matrixCodeType: '3x3',\n    // Pattern ratio for custom markers\n    patternRatio: 0.5\n    // Labeling mode for markers - ['black_region', 'white_region']\n    // black_region: Black bordered markers on a white background, white_region: White bordered markers on a black background\n    labelingMode: 'black_region',\n\n    // url of the camera parameters\n    cameraParametersUrl: THREEx.ArToolkitContext.baseURL + '../data/data/camera_para.dat',\n\n    // tune the maximum rate of pose detection in the source image\n    maxDetectionRate: 60,\n    // resolution of at which we detect pose in the source image\n    canvasWidth: 640,\n    canvasHeight: 480,\n\n    // enable image smoothing or not for canvas copy - default to true\n    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/imageSmoothingEnabled\n    imageSmoothingEnabled : true,\n}\n")])])]),a("p",[e._v("THREEx.ArToolkitSource")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var parameters = {\n  // type of source - ['webcam', 'image', 'video']\n  sourceType: \"webcam\",\n  // url of the source - valid if sourceType = image|video\n  sourceUrl: null,\n\n  // resolution of at which we initialize the source image\n  sourceWidth: 640,\n  sourceHeight: 480,\n  // resolution displayed for the source\n  displayWidth: 640,\n  displayHeight: 480\n};\n")])])])])}),[],!1,null,null,null);t.default=o.exports}}]);