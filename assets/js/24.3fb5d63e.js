(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{314:function(t,e,a){"use strict";a.r(e);var s=a(28),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"ecs框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ecs框架"}},[t._v("#")]),t._v(" ECS框架")]),t._v(" "),a("p",[t._v("A-Frame是一个具有实体组件系统（ECS）架构的3.js框架。ECS架构是3D和游戏开发中一种常见的、理想的模式，遵循的是超越继承和层次的组合原则。")]),t._v(" "),a("p",[t._v("ECS的好处包括：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("通过混合和匹配可重用部件来定义对象时具有更大的灵活性。")])]),t._v(" "),a("li",[a("p",[t._v("消除了复杂交织功能的长继承链问题。")])]),t._v(" "),a("li",[a("p",[t._v("通过解耦、封装、模块化、可重用性来促进清洁设计。")])]),t._v(" "),a("li",[a("p",[t._v("从复杂性的角度来看，构建虚拟现实应用程序的最具伸缩性的方法。")])]),t._v(" "),a("li",[a("p",[t._v("经过验证的3D和虚拟现实开发架构。")])]),t._v(" "),a("li",[a("p",[t._v("允许扩展新功能（可能将它们作为社区组件共享）。")])])]),t._v(" "),a("p",[t._v("在2dweb上，我们在层次结构中布局具有固定行为的元素。3D和VR是不同的；有无限类型的可能对象具有无限的行为。ECS提供了一个可管理的模式来构造对象类型。")]),t._v(" "),a("p",[t._v("以下是ECS架构的优秀入门资料。我们建议浏览一下，以便更好地了解这些好处。ECS非常适合虚拟现实开发，A-Frame完全基于这种模式：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("维基百科实体构件系统")])]),t._v(" "),a("li",[a("p",[t._v("什么是实体系统？亚当·马丁")])]),t._v(" "),a("li",[a("p",[t._v("解耦模式-游戏编程模式的组件")])]),t._v(" "),a("li",[a("p",[t._v("由米克韦斯特发展你的等级制度")])])]),t._v(" "),a("p",[t._v("实现ECS的著名游戏引擎是Unity。尽管在跨实体通信中存在一些难点，但我们将看到A-Frame、DOM和声明性HTML如何真正使ECS发光。")]),t._v(" "),a("h2",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),a("p",[t._v("ECS的基本定义包括：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("实体是可以附加组件的容器对象。实体是场景中所有对象的基础。如果没有组件，实体既不会也不会呈现任何内容，类似于empty")]),a("div",[t._v("s。"),a("p")])]),t._v(" "),a("li",[a("p",[t._v("组件是可重用的模块或数据容器，可以附加到实体以提供外观、行为和/或功能。组件就像对象的即插即用。所有逻辑都是通过组件实现的，我们通过混合、匹配和配置组件来定义不同类型的对象。就像炼金术！")])]),t._v(" "),a("li",[a("p",[t._v("系统为组件类提供全局范围、管理和服务。系统通常是可选的，但是我们可以使用它们来分离逻辑和数据；系统处理逻辑，组件充当数据容器。")])])]),t._v(" "),a("h2",{attrs:{id:"例子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[t._v("#")]),t._v(" 例子")]),t._v(" "),a("p",[t._v("通过组合不同组件构建的不同类型实体的一些抽象示例：")]),t._v(" "),a("ul",[a("li",[t._v("Box = Position + Geometry + Material")]),t._v(" "),a("li",[t._v("Light Bulb = Position + Light + Geometry + Material + Shadow")]),t._v(" "),a("li",[t._v("Sign = Position + Geometry + Material + Text")]),t._v(" "),a("li",[t._v("VR Controller = Position + Rotation + Input + Model + Grab + Gestures")]),t._v(" "),a("li",[t._v("Ball = Position + Velocity + Physics + Geometry + Material")]),t._v(" "),a("li",[t._v("Player = Position + Camera + Input + Avatar + Identity")])]),t._v(" "),a("p",[t._v("另一个抽象的例子是，假设我们想通过组装组件来构建一个汽车实体：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("我们可以附加一个具有影响汽车外观的“颜色”或“光泽”等特性的材料组件。")])]),t._v(" "),a("li",[a("p",[t._v("我们可以附加一个发动机部件，它具有影响汽车功能的“马力”或“重量”等特性。")])]),t._v(" "),a("li",[a("p",[t._v("我们可以附加一个轮胎部件，它具有“轮胎数量”或“转向角”等影响汽车性能的特性。")])])]),t._v(" "),a("p",[t._v("因此，我们可以通过改变材料、发动机和轮胎部件的特性来制造不同类型的汽车。材料、发动机和轮胎部件不必相互了解，甚至可以单独用于其他情况。我们可以将它们混合搭配，创造出甚至不同类型的车辆：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("创建船实体：移除轮胎组件。")])]),t._v(" "),a("li",[a("p",[t._v("创建摩托车实体：将轮胎组件的轮胎数更改为2，将发动机组件配置为更小。")])]),t._v(" "),a("li",[a("p",[t._v("创建飞机实体：附加机翼和喷气组件。")])])]),t._v(" "),a("p",[t._v("与传统的继承相比，如果我们想扩展一个对象，我们就必须创建一个大型类来处理所有事情或继承链。")]),t._v(" "),a("h2",{attrs:{id:"a-frame中的ecs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-frame中的ecs"}},[t._v("#")]),t._v(" A-Frame中的ECS")]),t._v(" "),a("p",[t._v("A-Frame有代表每台ECS的api：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("实体由"),a("a-entity",[t._v("元素和原型表示。")])],1)]),t._v(" "),a("li",[a("p",[t._v("组件由"),a("a-entity",[t._v("上的HTML属性表示。下面，组件是包含模式、生命周期处理程序和方法的对象。组件通过AFRAME.registerComponent（name,definition）API注册。")])],1)]),t._v(" "),a("li",[a("p",[t._v("系统由"),a("a-scene",[t._v("的HTML属性表示。系统在定义上类似于组件。系统通过AFRAME.registerSystem（name,definition）API注册。")])],1)])]),t._v(" "),a("h2",{attrs:{id:"语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[t._v("#")]),t._v(" 语法")]),t._v(" "),a("p",[t._v("我们创建"),a("a-entity",[t._v("并将组件作为HTML属性附加。大多数组件都有多个属性，这些属性由类似HTMLElement.StyleCSS的语法表示。此语法采用冒号（：）分隔属性名称和属性值的形式，分号（；）分隔不同的属性声明：")])],1),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity ${componentName}="${propertyName1}: ${propertyValue1}; ${propertyName2}: ${propertyValue2}">\n\n')])])]),a("p",[t._v("例如，我们有"),a("a-entity",[t._v("并附加具有各种属性和属性值的几何体、材质、灯光和位置组件：")])],1),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity geometry="primitive: sphere; radius: 1.5"\n          light="type: point; color: white; intensity: 2"\n          material="color: white; shader: flat; src: glow.jpg"\n          position="0 0 -5"></a-entity>\n\n')])])]),a("h2",{attrs:{id:"组合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组合"}},[t._v("#")]),t._v(" 组合")]),t._v(" "),a("p",[t._v("这样，我们可以附加更多的组件来添加额外的外观、行为或功能（例如，物理）。或者我们可以更新组件值来配置实体（声明性的或通过.setAttribute）。")]),t._v(" "),a("p",[t._v("由多个组件组成的一种常见实体类型是虚拟现实中玩家的手。玩家的手可以有许多组件：外观、手势、行为、与其他对象的交互。")]),t._v(" "),a("p",[t._v("我们将组件插入到一个hand实体中，以提供它的行为，就好像我们在为VR附加超能力或增强一样！下面的每个组件彼此不了解，但可以组合起来定义一个复杂的实体：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity\n  tracked-controls  \x3c!-- Hook into the Gamepad API for pose. --\x3e\n  vive-controls  \x3c!-- Vive button mappings. --\x3e\n  oculus-touch-controls  \x3c!-- Oculus button mappings. --\x3e\n  hand-controls  \x3c!-- Appearance (model), gestures, and events. --\x3e\n  laser-controls \x3c!-- Laser to interact with menus and UI. --\x3e\n  sphere-collider  \x3c!-- Listen when hand is in contact with an object. --\x3e\n  grab  \x3c!-- Provide ability to grab objects. --\x3e\n  throw \x3c!-- Provide ability to throw objects. --\x3e\n  event-set="_event: grabstart; visible: false"  \x3c!-- Hide hand when grabbing object. --\x3e\n  event-set="_event: grabend; visible: true"  \x3c!-- Show hand when no longer grabbing object. --\x3e\n>\n\n')])])]),a("h2",{attrs:{id:"基于dom声明式ecs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于dom声明式ecs"}},[t._v("#")]),t._v(" 基于DOM声明式ECS")]),t._v(" "),a("p",[t._v("A-Frame通过使ECS具有声明性并基于DOM将其带到另一个级别。传统上，基于ECS的引擎会通过代码创建实体、附加组件、更新组件、删除组件。但是A-Frame有HTML和DOM，这使得ECS符合人体工程学，解决了它的许多弱点。以下是DOM为ECS提供的功能：")]),t._v(" "),a("p",[t._v("使用查询选择器引用其他实体：DOM提供了一个强大的查询选择器系统，允许我们查询场景图并选择一个或多个符合条件的实体。我们可以通过id、类或数据属性获取对实体的引用。因为A-Frame是基于HTML的，所以我们可以使用开箱即用的查询选择器。document.querySelector（'#player'）。")]),t._v(" "),a("p",[t._v("与事件分离的跨实体通信：DOM提供了监听和发出事件的能力。这提供了实体之间的发布-订阅通信系统。组件不必知道彼此，它们只需发出一个事件（可能会冒泡），其他组件可以监听这些事件而不调用对方。ball.emit（“碰撞”）。")]),t._v(" "),a("p",[t._v("使用domapi进行生命周期管理的api:DOM提供了用于更新HTML元素和树的api，包括.setAttribute、.removeAttribute、.createElement和.removeChild。这些可以像在正常的web开发中一样使用。")]),t._v(" "),a("p",[t._v("使用属性选择器进行实体过滤：DOM提供属性选择器，允许我们查询具有或不具有特定HTML属性的一个或多个实体。这意味着我们可以请求具有或不具有特定组件集的实体。document.querySelector（'[敌人]：不是（[活着]）。")]),t._v(" "),a("p",[t._v("声明性：最后，DOM提供HTML。在ECS和HTML之间建立一个A-Frame桥，使得一个已经很干净的模式具有声明性、可读性、可复制和可粘贴")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("AFRAME.registerComponent('foo', {\n  schema: {\n    bar: {type: 'number'},\n    baz: {type: 'string'}\n  },\n\n  init: function () {\n    // Do something when component first attached.\n  },\n\n  update: function () {\n    // Do something when component's data is updated.\n  },\n\n  remove: function () {\n    // Do something the component or its entity is detached.\n  },\n\n  tick: function (time, timeDelta) {\n    // Do something on every scene tick or frame.\n  }\n});\n\n")])])]),a("p",[t._v("声明式ECS允许我们编写JavaScript模块并通过HTML抽象它。一旦注册了组件，我们就可以通过一个HTML属性声明性地将这个代码模块插入到一个实体中。这种代码到HTML的抽象使得ECS功能强大，易于推理。foo是我们刚刚注册的组件的名称，数据包含bar和baz属性：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity foo="bar: 5; baz: bazValue"></a-entity>\n\n')])])]),a("h3",{attrs:{id:"基于组件开发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于组件开发"}},[t._v("#")]),t._v(" 基于组件开发")]),t._v(" "),a("p",[t._v("对于构建虚拟现实应用程序，我们建议将所有应用程序代码放在组件（和系统）中。理想的A帧代码库完全由模块化、封装和分离的组件组成。这些组件可以单独或与其他组件一起进行单元测试。")]),t._v(" "),a("p",[t._v("当一个应用程序仅仅由组件创建时，它的代码库的所有部分都可以重用！组件可以共享给其他开发人员使用，或者我们可以在其他项目中重用它们。或者组件可以分叉和修改以适应其他用例。")]),t._v(" "),a("p",[t._v("一个简单的ECS代码库的结构可能如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("index.html\ncomponents/\n  ball.js\n  collidable.js\n  grabbable.js\n  enemy.js\n  scoreboard.js\n  throwable.js\n")])])]),a("h3",{attrs:{id:"高阶组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件"}},[t._v("#")]),t._v(" 高阶组件")]),t._v(" "),a("p",[t._v("组件可以在实体上设置其他组件，使它们成为抽象的更高阶或更高级别的组件。")]),t._v(" "),a("p",[t._v("例如，光标组件设置并构建在光线投射器组件的顶部。或者hand controls组件设置并构建在vive controls组件和oculus touch controls组件之上，而oculus touch controls组件又构建在tracked controls组件之上。")]),t._v(" "),a("h3",{attrs:{id:"社区组件生态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#社区组件生态"}},[t._v("#")]),t._v(" 社区组件生态")]),t._v(" "),a("p",[t._v("组件可以共享到A-Frame生态系统中供社区使用。A-Frame的ECS的优点是可扩展性。一个有经验的开发人员可以开发一个物理系统或图形着色器组件，而一个新手开发人员只需输入一个"),a("code",[t._v("<script>")]),t._v("标记，就可以从HTML中获取这些组件并在场景中使用它们。我们可以使用强大的已发布组件，而无需接触JavaScript。")]),t._v(" "),a("h3",{attrs:{id:"在何处查找组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在何处查找组件"}},[t._v("#")]),t._v(" 在何处查找组件")]),t._v(" "),a("p",[t._v("野外有数百种成分。我们尽力让他们被发现。如果你开发了一个组件，请通过这些渠道提交分享！")]),t._v(" "),a("h4",{attrs:{id:"npm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#npm"}},[t._v("#")]),t._v(" NPM")]),t._v(" "),a("p",[t._v("大多数A-Frame组件都发布在npm和GitHub上。我们可以使用npm的搜索来搜索aframe组件。npm允许我们按质量、流行度和维护进行排序。这是一个寻找更完整组件列表的好地方。")]),t._v(" "),a("h4",{attrs:{id:"github"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#github"}},[t._v("#")]),t._v(" github")]),t._v(" "),a("p",[t._v("许多A-Frame应用程序纯粹是从组件开发的，其中许多A-Frame应用程序都是在GitHub上开源的。它们的代码库将包含我们可以直接使用、引用或复制的组件。要查看的项目包括：")]),t._v(" "),a("ul",[a("li",[t._v("BeatSaver Viewer")]),t._v(" "),a("li",[t._v("Super Says")]),t._v(" "),a("li",[t._v("A-Painter")]),t._v(" "),a("li",[t._v("A-Blast")])]),t._v(" "),a("h3",{attrs:{id:"使用社区组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用社区组件"}},[t._v("#")]),t._v(" 使用社区组件")]),t._v(" "),a("p",[t._v("找到要使用的组件后，我们可以将该组件作为"),a("code",[t._v("<script>")]),t._v("标记包含并从HTML中使用它。")]),t._v(" "),a("p",[t._v("例如，让我们使用IdeaSpaceVR的粒子系统组件：")]),t._v(" "),a("h4",{attrs:{id:"使用unpkg"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用unpkg"}},[t._v("#")]),t._v(" 使用unpkg")]),t._v(" "),a("p",[t._v("首先，我们必须获取指向组件JS文件的CDN链接。组件的文档通常有一个CDN链接或使用信息。获得最新CDN链接的一种方法是使用"),a("code",[t._v("unpkg.com")]),t._v("。")]),t._v(" "),a("p",[t._v("unpkg是一个CDN，它自动承载发布到npm的所有内容。unpkg可以解析语义版本控制，并为我们提供所需组件的版本。URL的形式为：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("https://unpkg.com/<npm package name>@<version>/<path to file>\n")])])]),a("p",[t._v("如果要使用最新版本，可以去掉version")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("https://unpkg.com/<npm package name>/<path to file>\n")])])]),a("p",[t._v("我们可以排除path to file来浏览组件包的目录，而不是键入构建组件JS文件的路径。JS文件通常位于名为dist/或build/的文件夹中，以.min.JS结尾。")]),t._v(" "),a("p",[t._v("对于粒子系统组件，我们将转到：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("https://unpkg.com/aframe-particle-system-component/\n\n")])])]),a("p",[t._v("注意结尾的斜线（/）。找到我们需要的文件，右击，点击复制链接地址，将CDN链接复制到剪贴板。")]),t._v(" "),a("h4",{attrs:{id:"引入组件js文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引入组件js文件"}},[t._v("#")]),t._v(" 引入组件JS文件")]),t._v(" "),a("p",[t._v("然后转到我们的HTML。在"),a("code",[t._v("<head>")]),t._v("下面、A-Frame JS"),a("code",[t._v("<script>")]),t._v("标记之后和"),a("A-scene",[t._v("之前，我们将使用"),a("code",[t._v("<script>")]),t._v("标记包含JS文件。")])],1),t._v(" "),a("p",[t._v("对于粒子系统组件，我们之前（在编写时）发现的CDN链接是：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("https://unpkg.com/aframe-particle-system-component@1.0.9/dist/aframe-particle-system-component.min.js\n")])])]),a("p",[t._v("现在我们可以将其包含到我们的HTML中：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<html>\n  <head>\n    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"><\/script>\n    <script src="https://unpkg.com/aframe-particle-system-component@1.0.9/dist/aframe-particle-system-component.min.js"><\/script>\n  </head>\n  <body>\n    <a-scene>\n    </a-scene>\n  </body>\n</html>\n\n')])])]),a("h4",{attrs:{id:"使用组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用组件"}},[t._v("#")]),t._v(" 使用组件")]),t._v(" "),a("p",[t._v("按照组件的文档说明如何在实现中使用它。但通常情况下，这种用法涉及将组件附加到实体并对其进行配置。对于粒子系统组件：")]),t._v(" "),a("p",[t._v("现在我们可以将其包含到我们的HTML中：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<html>\n  <head>\n    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"><\/script>\n    <script src="https://unpkg.com/aframe-particle-system-component@1.0.9/dist/aframe-particle-system-component.min.js"><\/script>\n  </head>\n  <body>\n    <a-scene>\n      <a-entity particle-system="preset: snow" position="0 0 -10"></a-entity>\n    </a-scene>\n  </body>\n</html>\n')])])]),a("h4",{attrs:{id:"例子-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#例子-2"}},[t._v("#")]),t._v(" 例子")]),t._v(" "),a("p",[t._v("下面是使用注册表中的各种社区组件和使用unpkg CDN的完整示例。我们可以重新混音或看看这个小故障的例子。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<html>\n  <head>\n    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"><\/script>\n    <script src="https://unpkg.com/aframe-animation-component@3.2.1/dist/aframe-animation-component.min.js"><\/script>\n    <script src="https://unpkg.com/aframe-particle-system-component@1.0.x/dist/aframe-particle-system-component.min.js"><\/script>\n    <script src="https://unpkg.com/aframe-extras.ocean@%5E3.5.x/dist/aframe-extras.ocean.min.js"><\/script>\n    <script src="https://unpkg.com/aframe-gradient-sky@1.0.4/dist/gradientsky.min.js"><\/script>\n  </head>\n  <body>\n    <a-scene>\n      <a-entity id="rain" particle-system="preset: rain; color: #24CAFF; particleCount: 5000"></a-entity>\n\n      <a-entity id="sphere" geometry="primitive: sphere"\n                material="color: #EFEFEF; shader: flat"\n                position="0 0.15 -5"\n                light="type: point; intensity: 5"\n                animation="property: position; easing: easeInOutQuad; dir: alternate; dur: 1000; to: 0 -0.10 -5; loop: true"></a-entity>\n\n      <a-entity id="ocean" ocean="density: 20; width: 50; depth: 50; speed: 4"\n                material="color: #9CE3F9; opacity: 0.75; metalness: 0; roughness: 1"\n                rotation="-90 0 0"></a-entity>\n\n      <a-entity id="sky" geometry="primitive: sphere; radius: 5000"\n                material="shader: gradient; topColor: 235 235 245; bottomColor: 185 185 210"\n                scale="-1 1 1"></a-entity>\n\n      <a-entity id="light" light="type: ambient; color: #888"></a-entity>\n    </a-scene>\n  </body>\n</html>\n')])])])])}),[],!1,null,null,null);e.default=n.exports}}]);