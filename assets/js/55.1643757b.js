(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{364:function(t,e,a){"use strict";a.r(e);var s=a(28),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"位置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#位置"}},[t._v("#")]),t._v(" 位置")]),t._v(" "),a("p",[t._v("位置组件将实体放置在3D空间中的某些位置。位置将坐标值作为三个以空格分隔的数字。")]),t._v(" "),a("p",[t._v("所有实体固有地具有位置分量。")]),t._v(" "),a("h2",{attrs:{id:"例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#例"}},[t._v("#")]),t._v(" 例")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity position="0 1 -1"></a-entity>\n\n')])])]),a("h2",{attrs:{id:"值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#值"}},[t._v("#")]),t._v(" 值")]),t._v(" "),a("p",[t._v("A框架使用右手坐标系，其中负Z轴延伸到屏幕中。下表假设从原点向下看负Z轴。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("轴")]),t._v(" "),a("th",[t._v("描述")]),t._v(" "),a("th",[t._v("默认值")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("X")]),t._v(" "),a("td",[t._v("X负轴向左延伸。正X轴向右延伸。")]),t._v(" "),a("td",[t._v("0")])]),t._v(" "),a("tr",[a("td",[t._v("ÿ")]),t._v(" "),a("td",[t._v("负Y轴向下延伸。Y轴正向上延伸。")]),t._v(" "),a("td",[t._v("0")])]),t._v(" "),a("tr",[a("td",[t._v("ž")]),t._v(" "),a("td",[t._v("负Z轴向内延伸。正Z轴向外延伸。")]),t._v(" "),a("td",[t._v("0")])])])]),t._v(" "),a("h2",{attrs:{id:"相对定位"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相对定位"}},[t._v("#")]),t._v(" 相对定位")]),t._v(" "),a("p",[t._v("子实体的世界空间位置继承自父实体。考虑以下场景：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity id="parent" position="1 2 3">\n  <a-entity id="child1"></a-entity>\n  <a-entity id="child2" position="2 3 4"></a-entity>\n</a-entity>\n   \n')])])]),a("p",[t._v("的世界空间位置#child1将是1 2 3实体所继承的。在本地父母的空间中，#child1位置为0 0 0。")]),t._v(" "),a("p",[t._v("通过将位置与父实体结合起来，的世界空间位置#child2将为3 5 7。在父级的本地空间中，其#child2位置为2 3 4。")]),t._v(" "),a("h2",{attrs:{id:"更新位置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新位置"}},[t._v("#")]),t._v(" 更新位置")]),t._v(" "),a("p",[t._v("为了提高性能和人机工程学，我们建议直接通过three.js Object3D .position Vector3与via来 .setAttribute更新位置。")]),t._v(" "),a("p",[t._v("此方法更容易，因为我们可以访问所有Vector3实用程序，并且通过跳过.setAttribute开销并且不需要创建对象来设置位置就可以更快地进行访问：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// With three.js\nel.object3D.position.set(1, 2, 3);\n\n// With .setAttribute (less recommended).\nel.setAttribute('position', {x: 1, y: 2, z: 3});\n")])])]),a("p",[t._v("我们还可以进行增量更新（仅修改数字）并使用 Vector3实用程序：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("el.object3D.position.x + = 1 ; \nel.object3D.position.multiplyScalar（2）; \nel.object3D.position.sub（someOtherVector）;\n")])])]),a("h2",{attrs:{id:"取得位置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#取得位置"}},[t._v("#")]),t._v(" 取得位置")]),t._v(" "),a("p",[t._v("为了反映在three.js级别完成的更新，A-Frame Object3D.position在执行时会返回实际的 矢量对象.getAttribute('position')。注意修改返回值将修改实体本身。")]),t._v(" "),a("p",[t._v("另请参阅相机的读取位置和旋转。")]),t._v(" "),a("h2",{attrs:{id:"转换顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#转换顺序"}},[t._v("#")]),t._v(" 转换顺序")]),t._v(" "),a("p",[t._v("转换按以下顺序应用于实体：")]),t._v(" "),a("ul",[a("li",[t._v("伸缩")]),t._v(" "),a("li",[t._v("旋转")]),t._v(" "),a("li",[t._v("位置/转换")])])])}),[],!1,null,null,null);e.default=v.exports}}]);