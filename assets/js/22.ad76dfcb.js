(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{311:function(e,t,a){"use strict";a.r(t);var n=a(28),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"编写组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编写组件"}},[e._v("#")]),e._v(" 编写组件")]),e._v(" "),a("p",[e._v("A-Frame的实体组件框架的组件是JavaScript模块，可以混合、匹配和组合到实体上以构建外观、行为和功能。我们可以在JavaScript中注册组件，并从DOM中声明性地使用它。组件是可配置的、可重用的和可共享的。A-Frame应用程序中的大多数代码应该位于组件中。")]),e._v(" "),a("p",[e._v("这个导游会慢慢来的。我们建议在阅读本指南之前先浏览一下组件API文档，因为该文档将更加简洁。注意，组件应该在"),a("a-scene",[e._v("之前定义，比如：")])],1),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<html>\n  <head>\n    <script src=\"foo-component.js\"><\/script>\n  </head>\n  <body>\n    <script>\n      // Or inline before the <a-scene>.\n      AFRAME.registerComponent('bar', {\n        // ...\n      });\n    <\/script>\n\n    <a-scene>\n    </a-scene>\n  </body>\n</html>\n")])])]),a("p",[e._v("我们将复习有关编写组件的示例。这些示例将主要完成一些琐碎的工作，但将演示数据流、API和用法。要查看非平凡组件的示例，请参阅生态系统中的“通过组件学习”部分。")]),e._v(" "),a("h2",{attrs:{id:"示例：hello-world组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#示例：hello-world组件"}},[e._v("#")]),e._v(" 示例：hello world组件")]),e._v(" "),a("p",[e._v("让我们从最基本的组成部分开始，了解一个大致的概念。当使用.init（）处理程序附加组件的实体时，此组件将记录一条简单消息。")]),e._v(" "),a("h3",{attrs:{id:"向aframe-registercomponent注册组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#向aframe-registercomponent注册组件"}},[e._v("#")]),e._v(" 向AFRAME.registerComponent注册组件")]),e._v(" "),a("p",[e._v("组件是用AFRAME.registerComponent（）注册的。我们传递组件的名称，该名称将用作组件在DOM中的表示形式中的HTML属性名。然后我们传递组件定义，它是一个包含方法和属性的JavaScript对象。在定义中，我们可以定义生命周期处理程序方法。其中之一是.init（），当组件第一次插入其实体时调用一次。")]),e._v(" "),a("p",[e._v("在下面的示例中，我们只需要让.init（）处理程序记录一条简单的消息。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('hello-world', {\n  init: function () {\n    console.log('Hello, World!');\n  }\n});\n\n")])])]),a("h3",{attrs:{id:"使用html中的组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用html中的组件"}},[e._v("#")]),e._v(" 使用HTML中的组件")]),e._v(" "),a("p",[e._v("然后我们可以声明性地使用hello world组件作为HTML属性。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<a-scene>\n  <a-entity hello-world></a-entity>\n</a-scene>\n\n")])])]),a("p",[e._v("现在，在附加并初始化实体之后，它将初始化我们的hello world组件。组件的奇妙之处在于，它们只有在实体准备好之后才被调用。我们不必担心等待场景或实体建立，它只会工作！如果我们检查控制台，你好，世界！将在场景开始运行并附加实体后记录一次。")]),e._v(" "),a("h3",{attrs:{id:"使用js中的组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用js中的组件"}},[e._v("#")]),e._v(" 使用JS中的组件")]),e._v(" "),a("p",[e._v("另一种设置组件的方法是使用.setAttribute（）以编程方式设置组件，而不是通过静态HTML。scene元素也可以使用组件，让我们以编程方式在场景上设置hello world组件：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("document.querySelector('a-scene').setAttribute('hello-world', '');\n\n")])])]),a("h2",{attrs:{id:"示例：日志组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#示例：日志组件"}},[e._v("#")]),e._v(" 示例：日志组件")]),e._v(" "),a("p",[e._v("类似于hello world组件，让我们创建一个日志组件。它仍然只会做console.log，但是我们将使它能够不仅仅是Hello，World！。我们的日志组件将记录传入的任何字符串。我们将通过通过模式定义可配置属性来了解如何将数据传递给组件。")]),e._v(" "),a("h3",{attrs:{id:"使用架构定义属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用架构定义属性"}},[e._v("#")]),e._v(" 使用架构定义属性")]),e._v(" "),a("p",[e._v("架构定义其组件的属性。作为类比，如果我们把组件看作函数，那么组件的属性就像它的函数参数。属性具有名称（如果组件具有多个属性）、默认值和属性类型。属性类型定义数据作为字符串（即从DOM）传递时如何解析数据。")]),e._v(" "),a("p",[e._v("对于日志组件，让我们通过模式定义一个消息属性类型。消息属性类型将有一个字符串属性类型，默认值为Hello，World！:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('log', {\n  schema: {\n    message: {type: 'string', default: 'Hello, World!'}\n  },\n  // ...\n});\n\n")])])]),a("h3",{attrs:{id:"使用生命周期处理程序中的属性数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用生命周期处理程序中的属性数据"}},[e._v("#")]),e._v(" 使用生命周期处理程序中的属性数据")]),e._v(" "),a("p",[e._v("字符串属性类型不会对传入的数据进行任何分析，并将按原样将其传递给生命周期方法处理程序。现在让我们来console.log这个消息属性类型。与hello world组件一样，我们编写了一个.init（）处理程序，但这次我们不会记录硬编码字符串。组件的属性类型值可通过this.data获得。所以让我们记录下这个.data.message！")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('log', {\n  schema: {\n    message: {type: 'string', default: 'Hello, World!'}\n  },\n\n  init: function () {\n    console.log(this.data.message);\n  }\n});\n\n")])])]),a("p",[e._v("然后从HTML中，我们可以将组件附加到实体。对于多属性组件，语法与内联css样式相同（属性名称/值对用：分隔，属性用；）分隔：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<a-scene>\n  <a-entity log="message: Hello, Metaverse!"></a-entity>\n</a-scene>\n\n')])])]),a("h3",{attrs:{id:"处理属性更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理属性更新"}},[e._v("#")]),e._v(" 处理属性更新")]),e._v(" "),a("p",[e._v("到目前为止，我们只使用了.init（）处理程序，该处理程序在组件生命周期开始时只调用一次，并且只有其初始属性。但是组件的属性通常是动态更新的。我们可以使用.update（）处理程序来处理属性更新。\n为了演示这一点，我们将只在日志组件的实体发出事件时使用日志组件。首先，我们将添加一个事件属性类型，该类型指定组件应侦听的事件。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// ...\nschema: {\n  event: {type: 'string', default: ''},\n  message: {type: 'string', default: 'Hello, World!'},\n},\n// ...\n")])])]),a("p",[e._v("然后我们将把所有东西从.init（）处理程序移到.update（）处理程序。当附加组件时，.update（）处理程序也在.init（）之后调用。有时，我们的大部分逻辑都在.update（）处理程序中，因此我们可以一次初始化和处理所有更新，而无需重复代码。")]),e._v(" "),a("p",[e._v("我们要做的是添加一个事件侦听器，它将在记录消息之前侦听事件。如果未指定事件属性类型，则只记录消息：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('log', {\n  schema: {\n    event: {type: 'string', default: ''},\n    message: {type: 'string', default: 'Hello, World!'}\n  },\n\n  update: function () {\n    var data = this.data;  // Component property values.\n    var el = this.el;  // Reference to the component's entity.\n\n    if (data.event) {\n      // This will log the `message` when the entity emits the `event`.\n      el.addEventListener(data.event, function () {\n        console.log(data.message);\n      });\n    } else {\n      // `event` not specified, just log the message.\n      console.log(data.message);\n    }\n  }\n});\n\n")])])]),a("p",[e._v("现在我们已经添加了事件侦听器属性，让我们来处理实际的属性更新。当事件属性类型更改时（例如，由于.setAttribute（），我们需要删除以前的事件侦听器，并添加一个新的事件侦听器。")]),e._v(" "),a("p",[e._v("但是要删除事件侦听器，我们需要对函数的引用。因此，当我们附加事件侦听器时，我们首先将函数存储在this.eventHandlerFn上。当我们通过此将属性附加到组件时，它们将在所有其他生命周期处理程序中可用。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('log', {\n  schema: {\n    event: {type: 'string', default: ''},\n    message: {type: 'string', default: 'Hello, World!'}\n  },\n\n  init: function () {\n    // Closure to access fresh `this.data` from event handler context.\n    var self = this;\n\n    // .init() is a good place to set up initial state and variables.\n    // Store a reference to the handler so we can later remove it.\n    this.eventHandlerFn = function () { console.log(self.data.message); };\n  },\n\n  update: function () {\n    var data = this.data;\n    var el = this.el;\n\n    if (data.event) {\n      el.addEventListener(data.event, this.eventHandlerFn);\n    } else {\n      console.log(data.message);\n    }\n  }\n});\n\n")])])]),a("p",[e._v("现在我们已经存储了事件处理函数。我们可以在事件属性类型更改时删除事件侦听器。我们只想在事件属性类型更改时更新事件侦听器。我们通过对照.update（）处理程序提供的oldData参数检查this.data来完成此操作：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('log', {\n  schema: {\n    event: {type: 'string', default: ''},\n    message: {type: 'string', default: 'Hello, World!'}\n  },\n\n  init: function () {\n    var self = this;\n    this.eventHandlerFn = function () { console.log(self.data.message); };\n  },\n\n  update: function (oldData) {\n    var data = this.data;\n    var el = this.el;\n\n    // `event` updated. Remove the previous event listener if it exists.\n    if (oldData.event && data.event !== oldData.event) {\n      el.removeEventListener(oldData.event, this.eventHandlerFn);\n    }\n\n    if (data.event) {\n      el.addEventListener(data.event, this.eventHandlerFn);\n    } else {\n      console.log(data.message);\n    }\n  }\n});\n\n")])])]),a("p",[e._v("现在让我们使用更新事件侦听器测试组件。这是我们的场景：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<a-scene>\n  <a-entity log="event: anEvent; message: Hello, Metaverse!"></a-entity>\n</a-scene>\n\n')])])]),a("p",[e._v("让我们的实体发出事件来测试它：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var el = document.querySelector('a-entity');\nel.emit('anEvent');\n// >> \"Hello, Metaverse!\"\n\n")])])]),a("p",[e._v("现在让我们更新事件以测试.update（）处理程序：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var el = document.querySelector('a-entity');\nel.setAttribute('log', {event: 'anotherEvent', message: 'Hello, new event!'});\nel.emit('anotherEvent');\n// >> \"Hello, new event!\"\n\n")])])]),a("h3",{attrs:{id:"组件删除处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件删除处理"}},[e._v("#")]),e._v(" 组件删除处理")]),e._v(" "),a("p",[e._v("让我们处理组件从实体中拔出的情况（即removeAttribute（'log'））。我们可以实现.remove（）处理程序，该处理程序在删除组件时调用。对于日志组件，我们移除附加到实体的组件的任何事件侦听器：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('log', {\n  schema: {\n    event: {type: 'string', default: ''},\n    message: {type: 'string', default: 'Hello, World!'}\n  },\n\n  init: function () {\n    var self = this;\n    this.eventHandlerFn = function () { console.log(self.data.message); };\n  },\n\n  update: function (oldData) {\n    var data = this.data;\n    var el = this.el;\n\n    if (oldData.event && data.event !== oldData.event) {\n      el.removeEventListener(oldData.event, this.eventHandlerFn);\n    }\n\n    if (data.event) {\n      el.addEventListener(data.event, this.eventHandlerFn);\n    } else {\n      console.log(data.message);\n    }\n  },\n\n  /**\n   * Handle component removal.\n   */\n  remove: function () {\n    var data = this.data;\n    var el = this.el;\n\n    // Remove event listener.\n    if (data.event) {\n      el.removeEventListener(data.event, this.eventHandlerFn);\n    }\n  }\n});\n\n")])])]),a("p",[e._v("现在让我们测试一下remove处理程序。让我们移除组件并检查发出事件是否不再执行任何操作：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<a-scene>\n  <a-entity log="event: anEvent; message: Hello, Metaverse!"></a-entity>\n</a-scene>\n\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var el = document.querySelector('a-entity');\nel.removeAttribute('log');\nel.emit('anEvent');\n// >> Nothing should be logged...\n\n")])])]),a("h3",{attrs:{id:"允许组件的多个实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#允许组件的多个实例"}},[e._v("#")]),e._v(" 允许组件的多个实例")]),e._v(" "),a("p",[e._v("让我们允许将多个日志组件附加到同一个实体。为此，我们使用.multiple标志启用多实例。让我们把它设为真：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('log', {\n  schema: {\n    event: {type: 'string', default: ''},\n    message: {type: 'string', default: 'Hello, World!'}\n  },\n\n  multiple: true,\n\n  // ...\n});\n")])])]),a("p",[e._v("多实例组件的属性名语法的形式为"),a("component",{attrs:{name:""}},[e._v("\\uuu"),a("ID",[e._v("，是带有ID后缀的双下划线。身份证可以是我们选择的任何东西。例如，在HTML中：")])],1)],1),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<a-scene>\n  <a-entity log__helloworld="message: Hello, World!"\n            log__metaverse="message: Hello, Metaverse!"></a-entity>\n</a-scene>\n\n')])])]),a("p",[e._v("或在JS中定义")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var el = document.querySelector('a-entity');\nel.setAttribute('log__helloworld', {message: 'Hello, World!'});\nel.setAttribute('log__metaverse', {message: 'Hello, Metaverse!'});\n\n")])])]),a("p",[e._v("在组件中，如果需要，我们可以使用this.id和this.attrName区分不同的实例。给定log\\uu helloworld，this.id将是helloworld，this.attrName将是完整的log\\uu helloworld。")]),e._v(" "),a("p",[e._v("我们有基本的日志组件！")]),e._v(" "),a("h2",{attrs:{id:"示例：长方体组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#示例：长方体组件"}},[e._v("#")]),e._v(" 示例：长方体组件")]),e._v(" "),a("p",[e._v("对于一个不那么简单的例子，让我们了解如何通过编写使用three.js的组件来添加3D对象并影响场景图。为了得到这个想法，我们只需要制作一个基本的长方体组件，它可以创建一个包含几何体和材质的长方体网格。")]),e._v(" "),a("p",[e._v("注意：这只是一个三维等价物写一个你好，世界！组件。如果我们真的想在实践中制作一个盒子，A-Frame提供了几何和材料组件。")]),e._v(" "),a("h3",{attrs:{id:"架构和api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构和api"}},[e._v("#")]),e._v(" 架构和API")]),e._v(" "),a("p",[e._v("让我们从架构开始。架构定义组件的API。我们将通过属性配置宽度、高度、深度和颜色。宽度、高度和深度将是数字类型（即浮动），默认值为1米。颜色类型将具有默认为灰色的颜色类型（即字符串）：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('box', {\n  schema: {\n    width: {type: 'number', default: 1},\n    height: {type: 'number', default: 1},\n    depth: {type: 'number', default: 1},\n    color: {type: 'color', default: '#AAA'}\n  }\n});\n")])])]),a("p",[e._v("稍后，当我们通过HTML使用这个组件时，语法如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<a-scene>\n  <a-entity box="width: 0.5; height: 0.25; depth: 1; color: orange"\n            position="0 0 -5"></a-entity>\n</a-scene>\n\n')])])]),a("h3",{attrs:{id:"创建长方体网格"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建长方体网格"}},[e._v("#")]),e._v(" 创建长方体网格")]),e._v(" "),a("p",[e._v("让我们从.init（）创建我们的3.js box网格，然后让.update（）处理程序处理所有属性更新。要在three.js中创建一个box，我们将创建一个three.BoxBufferGeometry、three.MeshStandardMaterial，最后创建一个three.Mesh。然后在实体上设置网格，使用.setObject3D（name，object）将网格添加到three.js场景图中：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('box', {\n  schema: {\n    width: {type: 'number', default: 1},\n    height: {type: 'number', default: 1},\n    depth: {type: 'number', default: 1},\n    color: {type: 'color', default: '#AAA'}\n  },\n\n  /**\n   * Initial creation and setting of the mesh.\n   */\n  init: function () {\n    var data = this.data;\n    var el = this.el;\n\n    // Create geometry.\n    this.geometry = new THREE.BoxBufferGeometry(data.width, data.height, data.depth);\n\n    // Create material.\n    this.material = new THREE.MeshStandardMaterial({color: data.color});\n\n    // Create mesh.\n    this.mesh = new THREE.Mesh(this.geometry, this.material);\n\n    // Set mesh on entity.\n    el.setObject3D('mesh', this.mesh);\n  }\n});\n\n")])])]),a("p",[e._v("现在让我们来处理更新。如果与几何体相关的属性（即宽度、高度、深度）更新，我们将只重新创建几何体。如果与材质相关的属性（即颜色）更新，我们将只在适当的位置更新材质。要访问网格来更新它，我们使用.getObject3D（'mesh'）。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('box', {\n  schema: {\n    width: {type: 'number', default: 1},\n    height: {type: 'number', default: 1},\n    depth: {type: 'number', default: 1},\n    color: {type: 'color', default: '#AAA'}\n  },\n\n  init: function () {\n    var data = this.data;\n    var el = this.el;\n    this.geometry = new THREE.BoxBufferGeometry(data.width, data.height, data.depth);\n    this.material = new THREE.MeshStandardMaterial({color: data.color});\n    this.mesh = new THREE.Mesh(this.geometry, this.material);\n    el.setObject3D('mesh', this.mesh);\n  },\n\n  /**\n   * Update the mesh in response to property updates.\n   */\n  update: function (oldData) {\n    var data = this.data;\n    var el = this.el;\n\n    // If `oldData` is empty, then this means we're in the initialization process.\n    // No need to update.\n    if (Object.keys(oldData).length === 0) { return; }\n\n    // Geometry-related properties changed. Update the geometry.\n    if (data.width !== oldData.width ||\n        data.height !== oldData.height ||\n        data.depth !== oldData.depth) {\n      el.getObject3D('mesh').geometry = new THREE.BoxBufferGeometry(data.width, data.height,\n                                                                    data.depth);\n    }\n\n    // Material-related properties changed. Update the material.\n    if (data.color !== oldData.color) {\n      el.getObject3D('mesh').material.color = new THREE.Color(data.color);\n    }\n  }\n});\n")])])]),a("h3",{attrs:{id:"移除长方体网格"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#移除长方体网格"}},[e._v("#")]),e._v(" 移除长方体网格")]),e._v(" "),a("p",[e._v("最后，我们将处理组件或实体何时被删除。在这种情况下，我们要从场景中移除网格。我们可以使用.remove（）处理程序和.removeObject3D（名称）来执行此操作：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('box', {\n  // ...\n\n  remove: function () {\n    this.el.removeObject3D('mesh');\n  }\n});\n\n")])])]),a("p",[e._v("这就构成了基本的3.js box组件！实际上，一个3.js组件可以做一些更有用的事情。任何可以在three.js中完成的东西都可以包装在一个A-Frame组件中，使其成为声明性的。因此，请查看three.js特性和生态系统，看看您可以编写哪些组件！")]),e._v(" "),a("h2",{attrs:{id:"示例：跟随组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#示例：跟随组件"}},[e._v("#")]),e._v(" 示例：跟随组件")]),e._v(" "),a("p",[e._v("让我们编写一个follow组件，告诉一个实体跟随另一个实体。这将演示.tick（）处理程序的使用，该处理程序将在渲染循环的每一帧上运行的连续运行行为添加到场景中。这也将展示实体之间的关系。")]),e._v(" "),a("h3",{attrs:{id:"架构和api-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构和api-2"}},[e._v("#")]),e._v(" 架构和API")]),e._v(" "),a("p",[e._v("首先，我们需要一个目标属性来指定要遵循的实体。A-Frame有一个选择器属性类型来完成这项任务，允许我们传入一个查询选择器并取回一个实体元素。我们还将添加一个speed属性（以m/s为单位）来指定实体应遵循的速度。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('follow', {\n  schema: {\n    target: {type: 'selector'},\n    speed: {type: 'number'}\n  }\n});\n")])])]),a("p",[e._v("稍后，当我们通过HTML使用这个组件时，语法如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<a-scene>\n  <a-box id="target-box" color="#5E82C5" position="-3 0 -5"></a-box>\n  <a-box follow="target: #target-box; speed: 1" color="#FF6B6B" position="3 0 -5"></a-box>\n</a-scene>\n\n')])])]),a("h3",{attrs:{id:"创建辅助向量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建辅助向量"}},[e._v("#")]),e._v(" 创建辅助向量")]),e._v(" "),a("p",[e._v("由于.tick（）处理程序将在每一帧上调用（例如，每秒90次），我们希望确保它的性能。我们不想做的一件事是在每个刻度上创建不必要的对象，比如3.Vector3对象。这将有助于导致垃圾收集暂停。由于我们需要使用3.Vector3执行一些向量操作，因此我们将在.in it（）处理程序中创建一次，以便以后可以重用它：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('follow', {\n  schema: {\n    target: {type: 'selector'},\n    speed: {type: 'number'}\n  },\n\n  init: function () {\n    this.directionVec3 = new THREE.Vector3();\n  }\n});\n\n")])])]),a("h3",{attrs:{id:"使用-tick（）处理程序定义行为"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-tick（）处理程序定义行为"}},[e._v("#")]),e._v(" 使用.tick（）处理程序定义行为")]),e._v(" "),a("p",[e._v("现在我们将编写.tick（）处理程序，以便组件以所需的速度不断地将实体移向其目标。A帧将全局场景正常运行时间作为自上一帧以来的时间和时间传递给tick（）处理程序，以毫秒为单位。我们可以使用timeDelta来计算实体在给定速度的情况下应该向目标移动多远。")]),e._v(" "),a("p",[e._v("为了计算实体应该进入的方向，我们从目标实体的方向向量中减去实体的位置向量。我们可以通过.object3D访问实体的3.js对象，然后从那里访问position vector.position。我们将方向向量存储在先前在init（）处理程序中分配的this.directionVec3中。")]),e._v(" "),a("p",[e._v("然后，我们将要走的距离、所需的速度以及自上一帧以来经过的时间作为因子，以找到要添加到实体位置的适当向量。我们使用.setAttribute转换实体，在下一帧中，.tick（）处理程序将再次运行。")]),e._v(" "),a("p",[e._v("下面是full.tick（）处理程序。tick（）很好，因为它允许一种简单的方式挂接到渲染循环中，而无需实际引用渲染循环。我们只需要定义一种方法。下面是代码注释：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AFRAME.registerComponent('follow', {\n  schema: {\n    target: {type: 'selector'},\n    speed: {type: 'number'}\n  },\n\n  init: function () {\n    this.directionVec3 = new THREE.Vector3();\n  },\n\n  tick: function (time, timeDelta) {\n    var directionVec3 = this.directionVec3;\n\n    // Grab position vectors (THREE.Vector3) from the entities' three.js objects.\n    var targetPosition = this.data.target.object3D.position;\n    var currentPosition = this.el.object3D.position;\n\n    // Subtract the vectors to get the direction the entity should head in.\n    directionVec3.copy(targetPosition).sub(currentPosition);\n\n    // Calculate the distance.\n    var distance = directionVec3.length();\n\n    // Don't go any closer if a close proximity has been reached.\n    if (distance < 1) { return; }\n\n    // Scale the direction vector's magnitude down to match the speed.\n    var factor = this.data.speed / distance;\n    ['x', 'y', 'z'].forEach(function (axis) {\n      directionVec3[axis] *= factor * (timeDelta / 1000);\n    });\n\n    // Translate the entity in the direction towards the target.\n    this.el.setAttribute('position', {\n      x: currentPosition.x + directionVec3.x,\n      y: currentPosition.y + directionVec3.y,\n      z: currentPosition.z + directionVec3.z\n    });\n  }\n});\n\n")])])]),a("h3",{attrs:{id:"通过生态系统的组成部分学习"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过生态系统的组成部分学习"}},[e._v("#")]),e._v(" 通过生态系统的组成部分学习")]),e._v(" "),a("p",[e._v("生态系统中有大量组件，其中大多数都是GitHub上的开源组件。学习的一种方法是浏览其他组件的源代码，看看它们是如何构建的，以及它们提供了哪些用例。这里有几个地方值得一看：")]),e._v(" "),a("ul",[a("li",[e._v("A-Frame core components - Source code of A-Frame’s standard components.")]),e._v(" "),a("li",[e._v("A-Painter components - Application-specific components for A-Painter.")]),e._v(" "),a("li",[e._v("A Week of A-Frame Weekly Series")]),e._v(" "),a("li",[e._v("Official Site")]),e._v(" "),a("li",[e._v("Community")]),e._v(" "),a("li",[e._v("Components on npm")]),e._v(" "),a("li",[e._v("Twitter")])]),e._v(" "),a("h2",{attrs:{id:"发布组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#发布组件"}},[e._v("#")]),e._v(" 发布组件")]),e._v(" "),a("p",[e._v("实际上，许多组件都是特定于应用程序的或一次性的组件。但是，如果您编写了一个对社区有用的组件，并且它的通用性足以在其他应用程序中工作，那么您应该发布它！")]),e._v(" "),a("p",[e._v("对于组件模板，我们建议使用角度。angle是a-Frame的命令行界面；它的一个功能是建立一个组件模板，用于发布到GitHub和npm，并且与生态系统中的所有其他组件保持一致。要安装模板：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("npm install -g angle && angle initcomponent\n\n")])])]),a("p",[e._v("initcomponent将要求一些信息，比如组件名，以便设置模板。编写一些代码、示例和文档，并发布到GitHub和npm！")])])}),[],!1,null,null,null);t.default=s.exports}}]);