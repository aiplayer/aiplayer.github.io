(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{362:function(t,e,a){"use strict";a.r(e);var r=a(28),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件"}},[t._v("#")]),t._v(" 组件")]),t._v(" "),a("p",[t._v("Raycaster组件\nraycaster组件提供了与raycaster的基于线的相交测试 。射线投射是一种将线从原点延伸到方向，并检查该线是否与其他实体相交的方法。")]),t._v(" "),a("p",[t._v("raycaster组件使用three.js raycaster。raycaster以一定间隔检查对象列表的相交，并在检测到相交或清除相交时（即，当raycaster不再与实体相交时）在实体上发出事件。")]),t._v(" "),a("p",[t._v("我们规定，光线投射器测试相交的对象集是通过objects下面描述的选择器属性明确定义的。光线投射是一项昂贵的操作，我们应该只对需要在任何给定时间进行交互的目标进行光线投射。")]),t._v(" "),a("p",[t._v("的光标部件和激光控制部件 都生成对raycaster组件的顶部上。")]),t._v(" "),a("h2",{attrs:{id:"例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#例"}},[t._v("#")]),t._v(" 例")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity id="player" collider-check>\n  <a-entity raycaster="objects: .collidable" position="0 -0.9 0" rotation="90 0 0"></a-entity>\n</a-entity>\n<a-entity class="collidable" geometry="primitive: box" position="1 0 0"></a-entity>\n\n')])])]),a("p",[t._v("每当实体添加或删除该类时collidable，raycaster都会刷新其对其进行射线广播的对象的列表。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("AFRAME.registerComponent('collider-check', {\n  dependencies: ['raycaster'],\n\n  init: function () {\n    this.el.addEventListener('raycaster-intersection', function () {\n      console.log('Player hit something!');\n    });\n  }\n});\n")])])]),a("h2",{attrs:{id:"特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("属性")]),t._v(" "),a("th",[t._v("描述")]),t._v(" "),a("th",[t._v("默认值")])])]),t._v(" "),a("tbody")]),t._v(" "),a("p",[t._v("自动刷新\t是否使用刷新观察器自动刷新raycaster的对象列表以测试交叉点，以检测添加或删除的实体和组件。\t真正\n方向\t射线应相对于实体原点指向哪个方向的Vector3坐标。\t0、0，-1\n已启用\traycaster是否正在积极检查交叉点。\t真正\n远\t返回结果实体的最大距离。不能低于near。\t无限\n间隔\t每个相交测试之间要等待的毫秒数。数字越小越有利于更快的更新。数字越大，性能越好。交叉测试每帧最多执行一次。\t0\n近\t返回索具实体的最小距离。不能小于0。\t0\n对象\t查询选择器以选择要测试相交的对象。如果未指定，将测试所有实体。请注意，.setObject3D将仅测试通过连接的对象及其递归子对象。\t空值\n起源\t相对于实体原点，光线应从何处起源的Vector3坐标。\t0、0、0\nshowLine\t是否使用线分量以可视方式显示光线投射器。\t假\nuseWorldCoordinates\t是否在世界坐标中指定了raycaster的原点和方向属性。\t假")]),t._v(" "),a("h2",{attrs:{id:"事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件"}},[t._v("#")]),t._v(" 事件")]),t._v(" "),a("p",[t._v("raycaster组件之所以有用，是因为它在实体上发出的事件。它将在光线投射实体和相交的实体上均发出事件。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("活动名称")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody")]),t._v(" "),a("p",[t._v("raycaster相交\t在相交的实体上发射。实体与光线投射器相交。事件详细信息将包含el，光线投射实体和intersection，以及.getIntersection (el)可用于获取当前路口数据的函数。\nraycaster相交清除\t在相交的实体上发射。实体不再与光线投射器相交。事件详细信息将包含elraycasting实体。\n雷卡斯特相交\t在光线投射实体上发射。Raycaster与一个或多个实体相交。事件详细信息将包含els，具有相交实体的数组和intersections，以及.getIntersection (el)可用于获取当前相交数据的函数。\nraycaster交叉口清除\t在光线投射实体上发射。Raycaster不再与一个或多个实体相交。事件详细信息将包含clearedEls，其中包含以前相交的实体的数组。")]),t._v(" "),a("h2",{attrs:{id:"相交对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相交对象"}},[t._v("#")]),t._v(" 相交对象")]),t._v(" "),a("p",[t._v("事件详细信息包含相交对象。它们直接从three.jsRaycaster.intersectObjects.返回 ：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("属性")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody")]),t._v(" "),a("p",[t._v("距离\t射线原点和交点之间的距离\n点\t相交点，以世界坐标表示\n面对\t相交的脸\nfaceIndex\t相交面的索引\n指标\t包含相交面的顶点索引\n宾语\t相交的物体\n紫外线\t相交点的U，V坐标")]),t._v(" "),a("h2",{attrs:{id:"会员"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#会员"}},[t._v("#")]),t._v(" 会员")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("会员")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody")]),t._v(" "),a("p",[t._v("相交的Els\t当前与光线投射器相交的实体。\n对象\tthree.js对象以测试交叉点。会scene.children如果objects没有指定属性。\n雷卡斯特\tthree.js raycaster对象。")]),t._v(" "),a("h2",{attrs:{id:"方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[t._v("#")]),t._v(" 方法")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("方法")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("getIntersection（el）")]),t._v(" "),a("td",[t._v("给定一个实体，返回当前的相交数据（如果有）。为方便起见，此方法也传递给路口事件详细信息。")])]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td",[t._v("refreshObjects")])])])]),t._v(" "),a("h2",{attrs:{id:"选择要测试相交的实体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#选择要测试相交的实体"}},[t._v("#")]),t._v(" 选择要测试相交的实体")]),t._v(" "),a("p",[t._v("射线广播是一种相对昂贵的操作。我们强烈建议并规定设置该objects属性，该属性将过滤光线投射器正在侦听的相交的实体。选择性相交对于限制相交测试实体的数量具有良好的性能，因为相交测试是每秒多次的操作。")]),t._v(" "),a("p",[t._v("要选择或选择我们要测试相交的实体，我们可以使用 objects属性。如果未定义此属性，则光线投射器将测试场景中的每个对象是否相交。objects采用查询选择器值：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity raycaster="objects: .clickable" cursor></a-entity>\n<a-entity class="clickable" geometry="primitive: box" position="1 0 0"></a-entity>\n<a-entity class="not-clickable" geometry="primitive: sphere" position="-1 0 0"></a-entity>\n')])])]),a("p",[t._v("在该示例中，我们可以通过设置或删除clickable类（el.classList.toggle('clickable')）将实体删除或添加到raycast列表中。筛选的另一种好方法是使用数据属性而不是类（[data-raycastable]和el.setAttribute('data-raycastable', '')）。")]),t._v(" "),a("h2",{attrs:{id:"收听raycaster交叉路口数据更改"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#收听raycaster交叉路口数据更改"}},[t._v("#")]),t._v(" 收听Raycaster交叉路口数据更改")]),t._v(" "),a("p",[t._v("当我们要侦听交点数据的变化时（例如，侦听实际交点的变化），可以使用该.getIntersection (el)方法，该方法采用一个实体，如果光线投射器当前与该实体相交，则返回交点数据。以下是在滴答处理程序中执行此操作的示例组件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("AFRAME.registerComponent('raycaster-listen', {\n\tinit: function () {\n    // Use events to figure out what raycaster is listening so we don't have to\n    // hardcode the raycaster.\n    this.el.addEventListener('raycaster-intersected', evt => {\n      this.raycaster = evt.detail.el;\n    });\n    this.el.addEventListener('raycaster-intersected-cleared', evt => {\n      this.raycaster = null;\n    });\n  },\n\n  tick: function () {\n    if (!this.raycaster) { return; }  // Not intersecting.\n\n    let intersection = this.raycaster.components.raycaster.getIntersection(this.el);\n    if (!intersection) { return; }\n    console.log(intersection.point);\n  }\n});\n\n// <a-entity id=\"raycaster\" raycaster></a-entity>\n// <a-entity geometry material raycaster-listen></a-entity>\n")])])]),a("p",[t._v("现在，在每个框架上，实体将检查其相交数据并对其进行处理（例如，在相交点绘制一个球体）。")]),t._v(" "),a("h2",{attrs:{id:"手动刷新raycaster的目标实体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手动刷新raycaster的目标实体"}},[t._v("#")]),t._v(" 手动刷新Raycaster的目标实体")]),t._v(" "),a("p",[t._v("raycaster组件保留一个对象和实体的本地数组，raycaster对其进行测试以进行相交。该数组默认为three.js场景中的每个3D对象。如果objects指定了属性，则构建此数组需要运行查询选择器和其他过滤。")]),t._v(" "),a("p",[t._v("默认情况下，autoRefresh设置为true，当raycaster组件检测到添加或删除实体或组件时，它将自动刷新此列表。尽管它对自动刷新更友好，但更高级的开发人员可能希望禁用autoRefresh和控制刷新raycaster的时间以提高性能。")]),t._v(" "),a("p",[t._v("要手动刷新raycaster组件要测试的对象列表，请调用以下.refreshObjects()方法：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var raycasterEl = AFRAME.scenes[0].querySelector('[raycaster]');\nraycasterEl.components.raycaster.refreshObjects();\n")])])]),a("p",[t._v(".refreshObjects()当实体从场景中追加或分离时，A-Frame将自动调用，但是在正常的DOM突变（例如，某些实体更改其class）期间将不会调用它。")]),t._v(" "),a("h2",{attrs:{id:"定制线"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定制线"}},[t._v("#")]),t._v(" 定制线")]),t._v(" "),a("p",[t._v("如果showLine设置为true，则raycaster将配置给定raycaster的线路origin，direction和far性能。要自定义showLine: true属性提供的线条外观，我们配置线条组件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<a-entity raycaster="showLine: true; far: 100" line="color: orange; opacity: 0.5"></a-entity>\n\n')])])]),a("p",[t._v("far当光线投射器不与任何实体相交时，线长是光线投射器的属性。默认情况下，该far属性默认为1000米，这意味着绘制的线长为1000米。当光线投射器与一个物体相交时，该线将被截断到相交点，因此它不会直射。")])])}),[],!1,null,null,null);e.default=s.exports}}]);