(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{278:function(t,n,e){"use strict";e.r(n);var a=e(28),i=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"平台游戏"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#平台游戏"}},[t._v("#")]),t._v(" 平台游戏")]),t._v(" "),e("p",[t._v("在本教程中，我们将学习如何在nunuStudio中创建一个简单的平台游戏。我们将探索如何控制物理元素，导入外部资源以及使用键盘和游戏手柄输入。")]),t._v(" "),e("p",[t._v("这大约需要2到3个小时才能完成，但是对于新程序员来说，花更长的时间是完全可以的，不要着急花时间去尝试理解本教程的每个步骤。")]),t._v(" "),e("p",[t._v("对于本教程，建议您具有一些以前的编程经验，但是我将尝试尽可能多地解释所需的每个代码。")]),t._v(" "),e("h2",{attrs:{id:"建立关卡"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#建立关卡"}},[t._v("#")]),t._v(" 建立关卡")]),t._v(" "),e("p",[t._v("让我们从为我们的游戏创建一个简单的关卡开始。我们游戏中的所有交互式对象都应使用物理对象创建。Phyics对象是不可见的，要使其在游戏中可见，我们需要在其上附加视觉表示。")]),t._v(" "),e("p",[t._v("首先添加一个物理立方体，当选中该物理立方体时，它将在编辑器中以绿色显示，但是当我们按开始时，它将变为隐身。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/a.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("现在让我们向多维数据集中添加一个视觉表示，我们可以通过创建一个新的多维数据集并将其附加为物理多维数据集的子级来实现。要将新多维数据集添加为物理多维数据集的子级，请将其拖动到物理多维数据集顶部的对象资源管理器中。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/b.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("向多维数据集添加视觉表示后，我们可以看到它落在现有地板下面，为防止这种情况，我们需要添加一些其他物理元素用作多维数据集的地板。")]),t._v(" "),e("p",[t._v("我们可以移动，调整大小和缩放立方体物理对象，并且子对象也会受到影响。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/c.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("新的物理元素需要配置为静态。静态物理元素不会四处移动，它们仅用作静态墙。要将其配置为静态，请选择它，然后在对象面板中将“类型”设置为“静态”。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/d.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("现在让我们向项目中添加相机，相机控制玩家如何看待世界，我们将使用透视相机，透视相机允许玩家感知深度并查看3D对象，正交相机是2D相机，他们不允许玩家感知距离。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/e.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("将摄像机添加到场景中后，我们需要将其设置为默认摄像机，以实现此目的，选择摄像机对象，然后在对象面板中选择“使用摄像机”选项。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/f.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("现在，让我们创建一种新材质，以便于区分我们的播放器和我们创建的墙。要创建新材质，请在资产浏览器中打开“材质”菜单，然后选择“标准”或“ Phong材质”。要将新材料应用于我们的对象，请将其从资产浏览器拖到该对象。我把我的颜色涂成红色，但是您可以选择任何颜色，甚至可以添加纹理。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/g.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("在将材质添加到我们将用作播放器的多维数据集之后，我们准备继续编码角色行为。如果一切都按预期进行，则您的计算机上应该有类似的东西。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/h.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("如果您在完成本教程的这一部分时遇到麻烦，可以下载项目文件，也可以下载项目文件或在Web编辑器上打开它。")]),t._v(" "),e("h2",{attrs:{id:"玩家控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#玩家控制"}},[t._v("#")]),t._v(" 玩家控制")]),t._v(" "),e("p",[t._v("要移动我们的播放器，我们需要创建一个新脚本，该脚本将用于使用键盘键控制播放器。脚本是对象，因此它们具有位置，旋转，比例等，并且可以将对象附加为子代。")]),t._v(" "),e("p",[t._v("要打开代码编辑器，请在对象资源管理器上双击脚本对象，或在其顶部单击鼠标右键，然后选择“脚本编辑器”，将使用代码编辑器打开一个新选项卡。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/i.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("在本教程中，我们将使用单个脚本对象来控制场景中的所有对象，但可能具有多个脚本。")]),t._v(" "),e("p",[t._v("让我们先在脚本中获取玩家对象，然后使用我们的名称获取玩家对象，然后将物理立方体（将用作玩家）重命名为玩家。之后，我们可以使用下面的代码获取播放器对象并将其存储在变量中。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var player;\n\nfunction initialize()\n{\n\tplayer = scene.getObjectByName("player");\n}\n')])])]),e("p",[t._v("为了获得键盘输入，我们有Keyboard对象，该对象提供keyPressed，keyJustPressed和keyJustRelease方法，这些方法使我们能够检测用户何时按下并释放了键盘中的特定键。在本指南中，我们将使用WASD键。")]),t._v(" "),e("p",[t._v("为了使玩家四处移动，我们将操纵其身体，物理身体具有位置，速度，加速度和力属性。我们改变了操纵那些来使玩家四处走动，为了更好地控制玩家的移动，我们将操纵速度属性。")]),t._v(" "),e("p",[t._v("要进行编码，可以检测用户何时按下A，W和D键，并相应地设置播放器速度。但是经过一段时间后，我们可以看到玩家掉下了平台，因为我们的身体是一个立方体，最终在其角上旋转了一点，改变了方向。要在键盘中使用其他键，请查看键盘API文档。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function update()\n{\n\tif(Keyboard.keyPressed(Keyboard.A))\n\t{\n\t\tplayer.body.velocity.x = -5;\n\t}\n\tif(Keyboard.keyPressed(Keyboard.D))\n\t{\n\t\tplayer.body.velocity.x = 5;\n\t}\n\t\n\tif(Keyboard.keyJustPressed(Keyboard.W))\n\t{\n\t\tplayer.body.velocity.y = 10;\n\t}\n}\n")])])]),e("p",[t._v("为了避免玩家掉落我们的水平，我们需要阻止其在Z轴上的移动，我们可以通过将其位置和/或速度强制为0来实现这一点。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function update()\n{\n\t...\n\n\tplayer.body.position.z = 0;\n}\n\n")])])]),e("p",[t._v("现在，每当玩家按住W键时，仍然有待解决的问题。我们只能让我们的玩家在接触地面时跳起来。为此，我们需要检查玩家是否在地面上，并创建一个新变量，当玩家接触地面时将其设置为true。")]),t._v(" "),e("p",[t._v("要检查玩家是否已经触地，我们将为cannon.js world postStep事件创建一个新的回调，每次物理引擎更新对象位置后都会调用此回调，我们可以获得接触点列表并检查如果这些接触点属于我们的玩家（如果他们属于），则说明我们的玩家正在与某些东西发生碰撞。现在我们只需要检查接触点的方向，为此，我们将检查接触点方向与表面法线的点积（假设法线朝上）是其底面，应使我们得到接近0，我们假定下面的任何值都是0.1，如果是，我们将canJump标志设置为true。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var player, world;\n\nfunction initialize()\n{\n\tworld = scene.world;\n\tplayer = scene.getObjectByName("player");\n\tplayer.canJump = false;\n\t\n\tvar up = new Vector3(0, 1, 0);\n\tvar temp = new Vector3(0, 0, 0);\n\t\n\tworld.addEventListener("postStep", function(e)\n\t{\n\t\tif(world.contacts.length > 0)\n\t\t{\n\t\t\tfor(var i = 0; i < world.contacts.length; i++)\n\t\t\t{\n\t\t\t\t//Get contact points\n\t\t\t\tvar contact = world.contacts[i];\n\t\t\t\t\n\t\t\t\t//Check if any of the physics elements in the contact is our player\n\t\t\t\tif(contact.bi.id === player.body.id || contact.bj.id === player.body.id)\n\t\t\t\t{\n\t\t\t\t\t//If our player is the first element negate direction and store in temp\n\t\t\t\t\tif(contact.bi.id === player.body.id)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontact.ni.negate(temp);\n\t\t\t\t\t}\n\t\t\t\t\t//Else store direction in temp\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcontact.ni.copy(temp);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//If dot product if near 0 player is touching the floor and can jump again\n\t\t\t\t\tif(temp.dot(up) > 0.1)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayer.canJump = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction update()\n{\n\t...\n\n\t\n\tif(player.canJump && Keyboard.keyJustPressed(Keyboard.W))\n\t{\n\t\tplayer.body.velocity.y = 10;\n\t\tplayer.canJump = false;\n\t}\n\t\n\t...\n\n}\n')])])]),e("p",[t._v("现在我们可以控制角色并使其在整个关卡中正确移动，但是我们的相机仍然是静态的，要使其跟随我们的角色，我们只需将其在X和Y坐标中的位置与玩家位置相等即可。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var player, world, camera;\n\nfunction initialize()\n{\n\tcamera = scene.getObjectByName("camera");\n\n\t...\n}\n\nfunction update()\n{\n\t...\n\n\tcamera.position.x = player.body.position.x;\n\tcamera.position.y = player.body.position.y + 2;\n}\n')])])]),e("p",[t._v("如果您在完成本教程的这一部分时遇到麻烦，可以下载项目文件，也可以下载项目文件或在Web编辑器上打开它。")]),t._v(" "),e("h2",{attrs:{id:"敌人"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#敌人"}},[t._v("#")]),t._v(" 敌人")]),t._v(" "),e("p",[t._v("我们让玩家移动，但我们仍然无法死去，也没有任何可避免的障碍或要杀死的敌人。不用担心，我们现在会处理。")]),t._v(" "),e("p",[t._v("让我们先将级别提高一些，在一些我们可以掉落的地方添加更多平台，最快的方法是复制我们已经存在的地板，然后旋转，缩放和移动它，请谨慎使用这些对物理对象的变化，而不是对视觉表示的变化。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/j.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("现在让我们创建一些障碍，首先让我们从静态障碍开始，然后让它们移动。我将添加红色障碍物并将播放器颜色更改为绿色，障碍物也将是静态物理对象。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/k.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("添加敌人后，让我们创建一个新的组并将所有敌人添加到该组中，以便我们可以将敌人与法线墙和其他物理对象区分开。在对象资源管理器中，新组应如下所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/l.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("现在让我们回到脚本并添加代码以检测与敌人的碰撞，让我们从向刚创建的组中添加的所有敌人添加属性“ isEnemy”开始。我们还需要存储播放器的生成位置，以便在我们死亡时回到该位置。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('function initialize()\n{\n\t...\n\n\tplayer.spawn = player.position.clone();\n\t\n\tvar enemies = scene.getObjectByName("enemies");\n\tfor(var i = 0; i < enemies.children.length; i++)\n\t{\n\t\tenemies.children[i].body.isEnemy = true;\n\t}\n\n\t...\n}\n')])])]),e("p",[t._v("此后，我们需要将敌人碰撞检查添加到在物理世界中创建的回调函数中的回调中，我们只需要检查是否存在isEnemy真值，如果是，则重置角色位置和速度。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('function initialize()\n{\n\t...\n\n\tworld.addEventListener("postStep", function(e)\n\t{\n\t\tif(world.contacts.length > 0)\n\t\t{\n\t\t\tfor(var i = 0; i < world.contacts.length; i++)\n\t\t\t{\n\t\t\t\t//Get contact points\n\t\t\t\tvar contact = world.contacts[i];\n\t\t\t\t\n\t\t\t\t//Check if any of the physics elements in the contact is our player\n\t\t\t\tif(contact.bi.id === player.body.id || contact.bj.id === player.body.id)\n\t\t\t\t{\n\t\t\t\t\t//Check if is an enemy\n\t\t\t\t\tif(contact.bi.isEnemy || contact.bj.isEnemy)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayer.body.position.set(player.spawn.x, player.spawn.y, player.spawn.z);\n\t\t\t\t\t\tplayer.body.velocity.set(0, 0, 0);\n\t\t\t\t\t}\n\n\t...\n}\n')])])]),e("p",[t._v("在继续移动敌人之前，让我们在地板下添加一个新的静态敌人，这样当玩家跌落到关卡时会死亡，该敌人不需要视觉表示。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/m.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("现在，让我们的敌人移动，让我们选择一个敌人，创建一个新脚本并将该脚本附加为我们选择的敌人的孩子。我们可以使敌人以几种不同的方式前进。")]),t._v(" "),e("p",[t._v("贝娄（Bellow）是此脚本使用的完整代码，它可以将对象从一个位置移动到另一个位置，可以对其进行调整以使其易于调整，并可以重复使用以移动其他对象（例如，创建移动平台）。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var velocity = 0.05;\nvar min = -5;\nvar max = 5;\nvar direction = 1;\n\nvar enemy;\n\nfunction initialize()\n{\n\t//Get enemy\n\tenemy = self.parent;\n\t\n\t//Store a copy of original position\n\tenemy.spawn = enemy.position.clone();\n}\n\nfunction update()\n{\n\t//Position direction\n\tif(direction > 0)\n\t{\n\t\t//Check if position reached max\n\t\tif(enemy.body.position.x < enemy.spawn.x + max)\n\t\t{\n\t\t\tenemy.body.position.x += velocity;\n\t\t}\n\t\t//Invert direction\n\t\telse\n\t\t{\n\t\t\tdirection = -1;\n\t\t}\n\t}\n\t//Negative direction\n\telse\n\t{\n\t\t//Check if position reached min\n\t\tif(enemy.body.position.x > enemy.spawn.x + min)\n\t\t{\n\t\t\tenemy.body.position.x -= velocity;\n\t\t}\n\t\t//Invert direction\n\t\telse\n\t\t{\n\t\t\tdirection = 1;\n\t\t}\n\t}\n}\n")])])]),e("p",[t._v("现在，您的游戏中应该有一个移动的敌人，复制创建的脚本并将其附加到其他对象上以使它们也移动，并尝试创建一个类似于超级马里奥游戏中的移动平台。")]),t._v(" "),e("p",[t._v("如果您在完成本教程的这一部分时遇到麻烦，可以下载项目文件，也可以下载项目文件或在Web编辑器上打开它。")]),t._v(" "),e("p",[t._v("游戏手柄输入\n为了增加对游戏板输入的支持，我们可以在脚本中创建一个游戏板对象，该游戏板对象允许我们从USB游戏板获取输入，不同的游戏板可能具有不同的按钮映射，您可以使用此网站来检查您的游戏板按钮映射。要检查Gamepad中其他按钮的名称，请查看Gamepad API文档。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var gamepad;\n\nfunction initialize()\n{\n\tgamepad = new Gamepad();\n\n\t...\n}\n\nfunction update()\n{\n\tgamepad.update();\n\t\n\tif(Keyboard.keyPressed(Keyboard.A) || gamepad.buttonPressed(Gamepad.LEFT))\n\t\n\t...\n}\n")])])]),e("h2",{attrs:{id:"放在一起"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#放在一起"}},[t._v("#")]),t._v(" 放在一起")]),t._v(" "),e("p",[t._v("现在，我们已经具有所有基本块，可以构成完整的平台游戏等级，让我们以实际游戏资产和调整游戏玩法来构建完整等级。为了更轻松地概述我们的关卡，我们可以使用2D编辑器模式（可以在场景浏览器的右上角切换）。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/n.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("现在已经差不多完成了添加纹理和装饰到我们的水平的时间，这是一个尝试使用某些装饰对象（如粒子，LensFlare等）的好时机。关于装饰，我并没有做太多事情，只需添加一些材质并为所有内容上色，添加了LensFlare效果，并且一些粒子漂浮在水平面上。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/o.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("由于玩家的动作也有些慢，因此我通过添加使用键盘Shift键运行的选项并对动作进行了微调，以调整其加速度曲线而不是即时移动。")]),t._v(" "),e("p",[t._v("在本教程的开始，我打算更改球的立方体或锁定其旋转，但是由于我发现看到立方体在滚动，这有点可笑，所以我将其保留为这样。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function update()\n{\n\n\t...\n\t\n\tvar velocity = 6;\n\tvar acceleration = 0.6;\n\t\n\tif(Keyboard.keyPressed(Keyboard.SHIFT))\n\t{\n\t\tvelocity = 8;\n\t\tacceleration = 1;\n\t}\n\t\n\tif(Keyboard.keyPressed(Keyboard.A) || gamepad.buttonPressed(Gamepad.LEFT))\n\t{\n\t\tif(player.body.velocity.x > -velocity)\n\t\t{\n\t\t\tplayer.body.velocity.x -= acceleration;\n\t\t}\n\t}\n\tif(Keyboard.keyPressed(Keyboard.D) || gamepad.buttonPressed(Gamepad.RIGHT))\n\t{\n\t\tif(player.body.velocity.x < velocity)\n\t\t{\n\t\t\tplayer.body.velocity.x += acceleration;\n\t\t}\n\t}\n\n\t...\n\n}\n")])])]),e("p",[t._v("结果\n如果您能做到这一点，那么您已经创建了一个awseome平台游戏。这应该涵盖平台游戏的所有基本方面。如果您对本教程中的任何步骤有疑问，请随时向我询问。")]),t._v(" "),e("p",[t._v("您可以尝试以下教程的最终结果（使用wsd键移动），也可以下载项目文件或在Web编辑器上打开它。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/run.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("调整播放器控件\n如果您希望使控件的感觉更像是经典平台游戏中的控件，而没有立方体在关卡附近滚动，则可以添加这些小调整")]),t._v(" "),e("p",[t._v("首先，我们需要将玩家物理对象更改为球体而不是立方体。这样我们的播放器就可以轻松滚动，而不会卡在墙上。我选择以(0.5, 0.5 , 0.5)适合我们(1.0, 1.0, 1.0)立方体的方式制作球体的比例。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/nunustudio/video/t.png",alt:"alt text"}})]),t._v(" "),e("p",[t._v("如您所见，红色也更改了角度阻尼值，这使得它在您释放按钮后不会滚远。您可以调整此值以找到最适合您的值。我发现0.999效果很好。")]),t._v(" "),e("p",[t._v("如您所见，还有一个名为“ playermesh”的蓝色立方体，该网格将代表我们的玩家。如果愿意，可以是自定义模型，但请确保更改球体比例以适合您的模型。")]),t._v(" "),e("p",[t._v("现在我们差不多完成了，我们要做的就是每帧将播放器网格物体传送到物理对象，我们可以通过在更新函数中将物理位置复制到播放器网格物体中来实现。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var playermesh;\n\nfunction initialize()\n{\n...\n\nplayermesh = scene.getObjectByName("playermesh");\n\n...\n};\n\nfunction update()\n{\n\t...\n\t\n\t//Copy the position of our physics object to our player mesh\n\tplayermesh.position.copy(player.body.position);\n\t\n\t...\n}\n')])])]),e("p",[t._v("如果按照所有步骤操作，您现在应该可以对播放器进行更流畅的控制。当然，您可以根据需要进行尝试。")]),t._v(" "),e("p",[t._v("如果您在完成本教程的这一部分时遇到麻烦，可以下载项目文件，也可以下载项目文件或在Web编辑器上打开它。")])])}),[],!1,null,null,null);n.default=i.exports}}]);